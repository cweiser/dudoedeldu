{"ast":null,"code":"/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\nimport * as time from './time.js';\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = [];\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue = [];\n};\n\n/**\n * @param {function():void} f\n */\nexport const enqueue = f => {\n  queue.push(f);\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0);\n  }\n};\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor(timeoutId) {\n    this._ = timeoutId;\n  }\n  destroy() {\n    clearFunction(this._);\n  }\n};\nconst Timeout = createTimeoutClass(clearTimeout);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout));\nconst Interval = createTimeoutClass(clearInterval);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const interval = (timeout, callback) => new Interval(setInterval(callback, timeout));\n\n/* c8 ignore next */\nexport const Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));\n\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next */\nexport const animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));\n\n/* c8 ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));\n\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @param {number} triggerAfter Optional. Trigger callback after a certain amount of time\n *                              without waiting for debounce.\n */\nexport const createDebouncer = (timeout, triggerAfter = -1) => {\n  let timer = -1;\n  /**\n   * @type {number?}\n    */\n  let lastCall = null;\n  /**\n   * @param {((...args: any)=>void)?} cb function to trigger after debounce. If null, it will reset the\n   *                         debounce.\n   */\n  return cb => {\n    clearTimeout(timer);\n    if (cb) {\n      if (triggerAfter >= 0) {\n        const now = time.getUnixTime();\n        if (lastCall === null) lastCall = now;\n        if (now - lastCall > triggerAfter) {\n          lastCall = null;\n          timer = /** @type {any} */setTimeout(cb, 0);\n          return;\n        }\n      }\n      timer = /** @type {any} */setTimeout(() => {\n        lastCall = null;\n        cb();\n      }, timeout);\n    } else {\n      lastCall = null;\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}