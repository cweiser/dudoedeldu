{"ast":null,"code":"/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport * as time from 'lib0/time';\nimport * as math from 'lib0/math';\nimport { Observable } from 'lib0/observable';\nimport * as f from 'lib0/function';\nimport * as Y from 'yjs'; // eslint-disable-line\n\nexport const outdatedTimeout = 30000;\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor(doc) {\n    super();\n    this.doc = doc;\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID;\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map();\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map();\n    this._checkInterval = /** @type {any} */setInterval(() => {\n      const now = time.getUnixTime();\n      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */this.meta.get(this.clientID).lastUpdated) {\n        // renew local clock\n        this.setLocalState(this.getLocalState());\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = [];\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid);\n        }\n      });\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout');\n      }\n    }, math.floor(outdatedTimeout / 10));\n    doc.on('destroy', () => {\n      this.destroy();\n    });\n    this.setLocalState({});\n  }\n  destroy() {\n    this.emit('destroy', [this]);\n    this.setLocalState(null);\n    super.destroy();\n    clearInterval(this._checkInterval);\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState() {\n    return this.states.get(this.clientID) || null;\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState(state) {\n    const clientID = this.clientID;\n    const currLocalMeta = this.meta.get(clientID);\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;\n    const prevState = this.states.get(clientID);\n    if (state === null) {\n      this.states.delete(clientID);\n    } else {\n      this.states.set(clientID, state);\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    });\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    if (state === null) {\n      removed.push(clientID);\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID);\n      }\n    } else {\n      updated.push(clientID);\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID);\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{\n        added,\n        updated: filteredUpdated,\n        removed\n      }, 'local']);\n    }\n    this.emit('update', [{\n      added,\n      updated,\n      removed\n    }, 'local']);\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField(field, value) {\n    const state = this.getLocalState();\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      });\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates() {\n    return this.states;\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = [];\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i];\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID);\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */awareness.meta.get(clientID);\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        });\n      }\n      removed.push(clientID);\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{\n      added: [],\n      updated: [],\n      removed\n    }, origin]);\n    awareness.emit('update', [{\n      added: [],\n      updated: [],\n      removed\n    }, origin]);\n  }\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length;\n  const encoder = encoding.createEncoder();\n  encoding.writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i];\n    const state = states.get(clientID) || null;\n    const clock = /** @type {MetaClientState} */awareness.meta.get(clientID).clock;\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(state));\n  }\n  return encoding.toUint8Array(encoder);\n};\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update);\n  const encoder = encoding.createEncoder();\n  const len = decoding.readVarUint(decoder);\n  encoding.writeVarUint(encoder, len);\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder);\n    const clock = decoding.readVarUint(decoder);\n    const state = JSON.parse(decoding.readVarString(decoder));\n    const modifiedState = modify(state);\n    encoding.writeVarUint(encoder, clientID);\n    encoding.writeVarUint(encoder, clock);\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState));\n  }\n  return encoding.toUint8Array(encoder);\n};\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update);\n  const timestamp = time.getUnixTime();\n  const added = [];\n  const updated = [];\n  const filteredUpdated = [];\n  const removed = [];\n  const len = decoding.readVarUint(decoder);\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder);\n    let clock = decoding.readVarUint(decoder);\n    const state = JSON.parse(decoding.readVarString(decoder));\n    const clientMeta = awareness.meta.get(clientID);\n    const prevState = awareness.states.get(clientID);\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock;\n    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++;\n        } else {\n          awareness.states.delete(clientID);\n        }\n      } else {\n        awareness.states.set(clientID, state);\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      });\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID);\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID);\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID);\n        }\n        updated.push(clientID);\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added,\n      updated: filteredUpdated,\n      removed\n    }, origin]);\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added,\n      updated,\n      removed\n    }, origin]);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}