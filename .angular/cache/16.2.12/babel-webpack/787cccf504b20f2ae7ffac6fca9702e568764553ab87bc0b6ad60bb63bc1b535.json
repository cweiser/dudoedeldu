{"ast":null,"code":"/* eslint-env browser */\n\n/**\n * Tiny websocket connection handler.\n *\n * Implements exponential backoff reconnects, ping/pong, and a nice event system using [lib0/observable].\n *\n * @module websocket\n */\n\nimport { Observable } from './observable.js';\nimport * as time from './time.js';\nimport * as math from './math.js';\nconst reconnectTimeoutBase = 1200;\nconst maxReconnectTimeout = 2500;\n// @todo - this should depend on awareness.outdatedTime\nconst messageReconnectTimeout = 30000;\n\n/**\n * @param {WebsocketClient} wsclient\n */\nconst setupWS = wsclient => {\n  if (wsclient.shouldConnect && wsclient.ws === null) {\n    const websocket = new WebSocket(wsclient.url);\n    const binaryType = wsclient.binaryType;\n    /**\n     * @type {any}\n     */\n    let pingTimeout = null;\n    if (binaryType) {\n      websocket.binaryType = binaryType;\n    }\n    wsclient.ws = websocket;\n    wsclient.connecting = true;\n    wsclient.connected = false;\n    websocket.onmessage = event => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      const data = event.data;\n      const message = typeof data === 'string' ? JSON.parse(data) : data;\n      if (message && message.type === 'pong') {\n        clearTimeout(pingTimeout);\n        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n      }\n      wsclient.emit('message', [message, wsclient]);\n    };\n    /**\n     * @param {any} error\n     */\n    const onclose = error => {\n      if (wsclient.ws !== null) {\n        wsclient.ws = null;\n        wsclient.connecting = false;\n        if (wsclient.connected) {\n          wsclient.connected = false;\n          wsclient.emit('disconnect', [{\n            type: 'disconnect',\n            error\n          }, wsclient]);\n        } else {\n          wsclient.unsuccessfulReconnects++;\n        }\n        // Start with no reconnect timeout and increase timeout by\n        // log10(wsUnsuccessfulReconnects).\n        // The idea is to increase reconnect timeout slowly and have no reconnect\n        // timeout at the beginning (log(1) = 0)\n        setTimeout(setupWS, math.min(math.log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);\n      }\n      clearTimeout(pingTimeout);\n    };\n    const sendPing = () => {\n      if (wsclient.ws === websocket) {\n        wsclient.send({\n          type: 'ping'\n        });\n      }\n    };\n    websocket.onclose = () => onclose(null);\n    websocket.onerror = error => onclose(error);\n    websocket.onopen = () => {\n      wsclient.lastMessageReceived = time.getUnixTime();\n      wsclient.connecting = false;\n      wsclient.connected = true;\n      wsclient.unsuccessfulReconnects = 0;\n      wsclient.emit('connect', [{\n        type: 'connect'\n      }, wsclient]);\n      // set ping\n      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);\n    };\n  }\n};\n\n/**\n * @deprecated\n * @extends Observable<string>\n */\nexport class WebsocketClient extends Observable {\n  /**\n   * @param {string} url\n   * @param {object} opts\n   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`\n   */\n  constructor(url, {\n    binaryType\n  } = {}) {\n    super();\n    this.url = url;\n    /**\n     * @type {WebSocket?}\n     */\n    this.ws = null;\n    this.binaryType = binaryType || null;\n    this.connected = false;\n    this.connecting = false;\n    this.unsuccessfulReconnects = 0;\n    this.lastMessageReceived = 0;\n    /**\n     * Whether to connect to other peers or not\n     * @type {boolean}\n     */\n    this.shouldConnect = true;\n    this._checkInterval = setInterval(() => {\n      if (this.connected && messageReconnectTimeout < time.getUnixTime() - this.lastMessageReceived) {\n        // no message received in a long time - not even your own awareness\n        // updates (which are updated every 15 seconds)\n        /** @type {WebSocket} */\n        this.ws.close();\n      }\n    }, messageReconnectTimeout / 2);\n    setupWS(this);\n  }\n\n  /**\n   * @param {any} message\n   */\n  send(message) {\n    if (this.ws) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n  destroy() {\n    clearInterval(this._checkInterval);\n    this.disconnect();\n    super.destroy();\n  }\n  disconnect() {\n    this.shouldConnect = false;\n    if (this.ws !== null) {\n      this.ws.close();\n    }\n  }\n  connect() {\n    this.shouldConnect = true;\n    if (!this.connected && this.ws === null) {\n      setupWS(this);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}