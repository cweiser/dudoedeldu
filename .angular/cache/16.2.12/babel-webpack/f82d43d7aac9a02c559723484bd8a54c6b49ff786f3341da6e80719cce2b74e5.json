{"ast":null,"code":"(function (e) {\n  if (\"object\" == typeof exports && \"undefined\" != typeof module) module.exports = e();else if (\"function\" == typeof define && define.amd) define([], e);else {\n    var t;\n    t = \"undefined\" == typeof window ? \"undefined\" == typeof global ? \"undefined\" == typeof self ? this : self : global : window, t.SimplePeer = e();\n  }\n})(function () {\n  var t = Math.floor,\n    n = Math.abs,\n    r = Math.pow;\n  return function () {\n    function d(s, e, n) {\n      function t(o, i) {\n        if (!e[o]) {\n          if (!s[o]) {\n            var l = \"function\" == typeof require && require;\n            if (!i && l) return l(o, !0);\n            if (r) return r(o, !0);\n            var c = new Error(\"Cannot find module '\" + o + \"'\");\n            throw c.code = \"MODULE_NOT_FOUND\", c;\n          }\n          var a = e[o] = {\n            exports: {}\n          };\n          s[o][0].call(a.exports, function (e) {\n            var r = s[o][1][e];\n            return t(r || e);\n          }, a, a.exports, d, s, e, n);\n        }\n        return e[o].exports;\n      }\n      for (var r = \"function\" == typeof require && require, a = 0; a < n.length; a++) t(n[a]);\n      return t;\n    }\n    return d;\n  }()({\n    1: [function (e, t, n) {\n      'use strict';\n\n      function r(e) {\n        var t = e.length;\n        if (0 < t % 4) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        var n = e.indexOf(\"=\");\n        -1 === n && (n = t);\n        var r = n === t ? 0 : 4 - n % 4;\n        return [n, r];\n      }\n      function a(e, t, n) {\n        return 3 * (t + n) / 4 - n;\n      }\n      function o(e) {\n        var t,\n          n,\n          o = r(e),\n          d = o[0],\n          s = o[1],\n          l = new p(a(e, d, s)),\n          c = 0,\n          f = 0 < s ? d - 4 : d;\n        for (n = 0; n < f; n += 4) t = u[e.charCodeAt(n)] << 18 | u[e.charCodeAt(n + 1)] << 12 | u[e.charCodeAt(n + 2)] << 6 | u[e.charCodeAt(n + 3)], l[c++] = 255 & t >> 16, l[c++] = 255 & t >> 8, l[c++] = 255 & t;\n        return 2 === s && (t = u[e.charCodeAt(n)] << 2 | u[e.charCodeAt(n + 1)] >> 4, l[c++] = 255 & t), 1 === s && (t = u[e.charCodeAt(n)] << 10 | u[e.charCodeAt(n + 1)] << 4 | u[e.charCodeAt(n + 2)] >> 2, l[c++] = 255 & t >> 8, l[c++] = 255 & t), l;\n      }\n      function d(e) {\n        return c[63 & e >> 18] + c[63 & e >> 12] + c[63 & e >> 6] + c[63 & e];\n      }\n      function s(e, t, n) {\n        for (var r, a = [], o = t; o < n; o += 3) r = (16711680 & e[o] << 16) + (65280 & e[o + 1] << 8) + (255 & e[o + 2]), a.push(d(r));\n        return a.join(\"\");\n      }\n      function l(e) {\n        for (var t, n = e.length, r = n % 3, a = [], o = 16383, d = 0, l = n - r; d < l; d += o) a.push(s(e, d, d + o > l ? l : d + o));\n        return 1 === r ? (t = e[n - 1], a.push(c[t >> 2] + c[63 & t << 4] + \"==\")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], a.push(c[t >> 10] + c[63 & t >> 4] + c[63 & t << 2] + \"=\")), a.join(\"\");\n      }\n      n.byteLength = function (e) {\n        var t = r(e),\n          n = t[0],\n          a = t[1];\n        return 3 * (n + a) / 4 - a;\n      }, n.toByteArray = o, n.fromByteArray = l;\n      for (var c = [], u = [], p = \"undefined\" == typeof Uint8Array ? Array : Uint8Array, f = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", g = 0, _ = f.length; g < _; ++g) c[g] = f[g], u[f.charCodeAt(g)] = g;\n      u[45] = 62, u[95] = 63;\n    }, {}],\n    2: [function () {}, {}],\n    3: [function (e, t, n) {\n      (function () {\n        (function () {\n          /*!\n          * The buffer module from node.js, for the browser.\n          *\n          * @author   Feross Aboukhadijeh <https://feross.org>\n          * @license  MIT\n          */\n          'use strict';\n\n          var t = String.fromCharCode,\n            o = Math.min;\n          function d(e) {\n            if (2147483647 < e) throw new RangeError(\"The value \\\"\" + e + \"\\\" is invalid for option \\\"size\\\"\");\n            var t = new Uint8Array(e);\n            return t.__proto__ = s.prototype, t;\n          }\n          function s(e, t, n) {\n            if (\"number\" == typeof e) {\n              if (\"string\" == typeof t) throw new TypeError(\"The \\\"string\\\" argument must be of type string. Received type number\");\n              return p(e);\n            }\n            return l(e, t, n);\n          }\n          function l(e, t, n) {\n            if (\"string\" == typeof e) return f(e, t);\n            if (ArrayBuffer.isView(e)) return g(e);\n            if (null == e) throw TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n            if (K(e, ArrayBuffer) || e && K(e.buffer, ArrayBuffer)) return _(e, t, n);\n            if (\"number\" == typeof e) throw new TypeError(\"The \\\"value\\\" argument must not be of type number. Received type number\");\n            var r = e.valueOf && e.valueOf();\n            if (null != r && r !== e) return s.from(r, t, n);\n            var a = h(e);\n            if (a) return a;\n            if (\"undefined\" != typeof Symbol && null != Symbol.toPrimitive && \"function\" == typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive](\"string\"), t, n);\n            throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof e);\n          }\n          function c(e) {\n            if (\"number\" != typeof e) throw new TypeError(\"\\\"size\\\" argument must be of type number\");else if (0 > e) throw new RangeError(\"The value \\\"\" + e + \"\\\" is invalid for option \\\"size\\\"\");\n          }\n          function u(e, t, n) {\n            return c(e), 0 >= e ? d(e) : void 0 === t ? d(e) : \"string\" == typeof n ? d(e).fill(t, n) : d(e).fill(t);\n          }\n          function p(e) {\n            return c(e), d(0 > e ? 0 : 0 | m(e));\n          }\n          function f(e, t) {\n            if ((\"string\" != typeof t || \"\" === t) && (t = \"utf8\"), !s.isEncoding(t)) throw new TypeError(\"Unknown encoding: \" + t);\n            var n = 0 | b(e, t),\n              r = d(n),\n              a = r.write(e, t);\n            return a !== n && (r = r.slice(0, a)), r;\n          }\n          function g(e) {\n            for (var t = 0 > e.length ? 0 : 0 | m(e.length), n = d(t), r = 0; r < t; r += 1) n[r] = 255 & e[r];\n            return n;\n          }\n          function _(e, t, n) {\n            if (0 > t || e.byteLength < t) throw new RangeError(\"\\\"offset\\\" is outside of buffer bounds\");\n            if (e.byteLength < t + (n || 0)) throw new RangeError(\"\\\"length\\\" is outside of buffer bounds\");\n            var r;\n            return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), r.__proto__ = s.prototype, r;\n          }\n          function h(e) {\n            if (s.isBuffer(e)) {\n              var t = 0 | m(e.length),\n                n = d(t);\n              return 0 === n.length ? n : (e.copy(n, 0, 0, t), n);\n            }\n            return void 0 === e.length ? \"Buffer\" === e.type && Array.isArray(e.data) ? g(e.data) : void 0 : \"number\" != typeof e.length || X(e.length) ? d(0) : g(e);\n          }\n          function m(e) {\n            if (e >= 2147483647) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + 2147483647 .toString(16) + \" bytes\");\n            return 0 | e;\n          }\n          function b(e, t) {\n            if (s.isBuffer(e)) return e.length;\n            if (ArrayBuffer.isView(e) || K(e, ArrayBuffer)) return e.byteLength;\n            if (\"string\" != typeof e) throw new TypeError(\"The \\\"string\\\" argument must be one of type string, Buffer, or ArrayBuffer. Received type \" + typeof e);\n            var n = e.length,\n              r = 2 < arguments.length && !0 === arguments[2];\n            if (!r && 0 === n) return 0;\n            for (var a = !1;;) switch (t) {\n              case \"ascii\":\n              case \"latin1\":\n              case \"binary\":\n                return n;\n              case \"utf8\":\n              case \"utf-8\":\n                return H(e).length;\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return 2 * n;\n              case \"hex\":\n                return n >>> 1;\n              case \"base64\":\n                return z(e).length;\n              default:\n                if (a) return r ? -1 : H(e).length;\n                t = (\"\" + t).toLowerCase(), a = !0;\n            }\n          }\n          function y(e, t, n) {\n            var r = !1;\n            if ((void 0 === t || 0 > t) && (t = 0), t > this.length) return \"\";\n            if ((void 0 === n || n > this.length) && (n = this.length), 0 >= n) return \"\";\n            if (n >>>= 0, t >>>= 0, n <= t) return \"\";\n            for (e || (e = \"utf8\");;) switch (e) {\n              case \"hex\":\n                return P(this, t, n);\n              case \"utf8\":\n              case \"utf-8\":\n                return x(this, t, n);\n              case \"ascii\":\n                return D(this, t, n);\n              case \"latin1\":\n              case \"binary\":\n                return I(this, t, n);\n              case \"base64\":\n                return A(this, t, n);\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return M(this, t, n);\n              default:\n                if (r) throw new TypeError(\"Unknown encoding: \" + e);\n                e = (e + \"\").toLowerCase(), r = !0;\n            }\n          }\n          function C(e, t, n) {\n            var r = e[t];\n            e[t] = e[n], e[n] = r;\n          }\n          function R(e, t, n, r, a) {\n            if (0 === e.length) return -1;\n            if (\"string\" == typeof n ? (r = n, n = 0) : 2147483647 < n ? n = 2147483647 : -2147483648 > n && (n = -2147483648), n = +n, X(n) && (n = a ? 0 : e.length - 1), 0 > n && (n = e.length + n), n >= e.length) {\n              if (a) return -1;\n              n = e.length - 1;\n            } else if (0 > n) if (a) n = 0;else return -1;\n            if (\"string\" == typeof t && (t = s.from(t, r)), s.isBuffer(t)) return 0 === t.length ? -1 : E(e, t, n, r, a);\n            if (\"number\" == typeof t) return t &= 255, \"function\" == typeof Uint8Array.prototype.indexOf ? a ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : E(e, [t], n, r, a);\n            throw new TypeError(\"val must be string, number or Buffer\");\n          }\n          function E(e, t, n, r, a) {\n            function o(e, t) {\n              return 1 === d ? e[t] : e.readUInt16BE(t * d);\n            }\n            var d = 1,\n              s = e.length,\n              l = t.length;\n            if (void 0 !== r && (r = (r + \"\").toLowerCase(), \"ucs2\" === r || \"ucs-2\" === r || \"utf16le\" === r || \"utf-16le\" === r)) {\n              if (2 > e.length || 2 > t.length) return -1;\n              d = 2, s /= 2, l /= 2, n /= 2;\n            }\n            var c;\n            if (a) {\n              var u = -1;\n              for (c = n; c < s; c++) if (o(e, c) !== o(t, -1 === u ? 0 : c - u)) -1 !== u && (c -= c - u), u = -1;else if (-1 === u && (u = c), c - u + 1 === l) return u * d;\n            } else for (n + l > s && (n = s - l), c = n; 0 <= c; c--) {\n              for (var p = !0, f = 0; f < l; f++) if (o(e, c + f) !== o(t, f)) {\n                p = !1;\n                break;\n              }\n              if (p) return c;\n            }\n            return -1;\n          }\n          function w(e, t, n, r) {\n            n = +n || 0;\n            var a = e.length - n;\n            r ? (r = +r, r > a && (r = a)) : r = a;\n            var o = t.length;\n            r > o / 2 && (r = o / 2);\n            for (var d, s = 0; s < r; ++s) {\n              if (d = parseInt(t.substr(2 * s, 2), 16), X(d)) return s;\n              e[n + s] = d;\n            }\n            return s;\n          }\n          function S(e, t, n, r) {\n            return G(H(t, e.length - n), e, n, r);\n          }\n          function T(e, t, n, r) {\n            return G(Y(t), e, n, r);\n          }\n          function v(e, t, n, r) {\n            return T(e, t, n, r);\n          }\n          function k(e, t, n, r) {\n            return G(z(t), e, n, r);\n          }\n          function L(e, t, n, r) {\n            return G(V(t, e.length - n), e, n, r);\n          }\n          function A(e, t, n) {\n            return 0 === t && n === e.length ? $.fromByteArray(e) : $.fromByteArray(e.slice(t, n));\n          }\n          function x(e, t, n) {\n            n = o(e.length, n);\n            for (var r = [], a = t; a < n;) {\n              var d = e[a],\n                s = null,\n                l = 239 < d ? 4 : 223 < d ? 3 : 191 < d ? 2 : 1;\n              if (a + l <= n) {\n                var c, u, p, f;\n                1 === l ? 128 > d && (s = d) : 2 === l ? (c = e[a + 1], 128 == (192 & c) && (f = (31 & d) << 6 | 63 & c, 127 < f && (s = f))) : 3 === l ? (c = e[a + 1], u = e[a + 2], 128 == (192 & c) && 128 == (192 & u) && (f = (15 & d) << 12 | (63 & c) << 6 | 63 & u, 2047 < f && (55296 > f || 57343 < f) && (s = f))) : 4 === l ? (c = e[a + 1], u = e[a + 2], p = e[a + 3], 128 == (192 & c) && 128 == (192 & u) && 128 == (192 & p) && (f = (15 & d) << 18 | (63 & c) << 12 | (63 & u) << 6 | 63 & p, 65535 < f && 1114112 > f && (s = f))) : void 0;\n              }\n              null === s ? (s = 65533, l = 1) : 65535 < s && (s -= 65536, r.push(55296 | 1023 & s >>> 10), s = 56320 | 1023 & s), r.push(s), a += l;\n            }\n            return N(r);\n          }\n          function N(e) {\n            var n = e.length;\n            if (n <= 4096) return t.apply(String, e);\n            for (var r = \"\", a = 0; a < n;) r += t.apply(String, e.slice(a, a += 4096));\n            return r;\n          }\n          function D(e, n, r) {\n            var a = \"\";\n            r = o(e.length, r);\n            for (var d = n; d < r; ++d) a += t(127 & e[d]);\n            return a;\n          }\n          function I(e, n, r) {\n            var a = \"\";\n            r = o(e.length, r);\n            for (var d = n; d < r; ++d) a += t(e[d]);\n            return a;\n          }\n          function P(e, t, n) {\n            var r = e.length;\n            (!t || 0 > t) && (t = 0), (!n || 0 > n || n > r) && (n = r);\n            for (var a = \"\", o = t; o < n; ++o) a += W(e[o]);\n            return a;\n          }\n          function M(e, n, r) {\n            for (var a = e.slice(n, r), o = \"\", d = 0; d < a.length; d += 2) o += t(a[d] + 256 * a[d + 1]);\n            return o;\n          }\n          function O(e, t, n) {\n            if (0 != e % 1 || 0 > e) throw new RangeError(\"offset is not uint\");\n            if (e + t > n) throw new RangeError(\"Trying to access beyond buffer length\");\n          }\n          function F(e, t, n, r, a, o) {\n            if (!s.isBuffer(e)) throw new TypeError(\"\\\"buffer\\\" argument must be a Buffer instance\");\n            if (t > a || t < o) throw new RangeError(\"\\\"value\\\" argument is out of bounds\");\n            if (n + r > e.length) throw new RangeError(\"Index out of range\");\n          }\n          function B(e, t, n, r) {\n            if (n + r > e.length) throw new RangeError(\"Index out of range\");\n            if (0 > n) throw new RangeError(\"Index out of range\");\n          }\n          function U(e, t, n, r, a) {\n            return t = +t, n >>>= 0, a || B(e, t, n, 4, 34028234663852886e22, -34028234663852886e22), J.write(e, t, n, r, 23, 4), n + 4;\n          }\n          function j(e, t, n, r, a) {\n            return t = +t, n >>>= 0, a || B(e, t, n, 8, 17976931348623157e292, -17976931348623157e292), J.write(e, t, n, r, 52, 8), n + 8;\n          }\n          function q(e) {\n            if (e = e.split(\"=\")[0], e = e.trim().replace(Q, \"\"), 2 > e.length) return \"\";\n            for (; 0 != e.length % 4;) e += \"=\";\n            return e;\n          }\n          function W(e) {\n            return 16 > e ? \"0\" + e.toString(16) : e.toString(16);\n          }\n          function H(e, t) {\n            t = t || 1 / 0;\n            for (var n, r = e.length, a = null, o = [], d = 0; d < r; ++d) {\n              if (n = e.charCodeAt(d), 55295 < n && 57344 > n) {\n                if (!a) {\n                  if (56319 < n) {\n                    -1 < (t -= 3) && o.push(239, 191, 189);\n                    continue;\n                  } else if (d + 1 === r) {\n                    -1 < (t -= 3) && o.push(239, 191, 189);\n                    continue;\n                  }\n                  a = n;\n                  continue;\n                }\n                if (56320 > n) {\n                  -1 < (t -= 3) && o.push(239, 191, 189), a = n;\n                  continue;\n                }\n                n = (a - 55296 << 10 | n - 56320) + 65536;\n              } else a && -1 < (t -= 3) && o.push(239, 191, 189);\n              if (a = null, 128 > n) {\n                if (0 > (t -= 1)) break;\n                o.push(n);\n              } else if (2048 > n) {\n                if (0 > (t -= 2)) break;\n                o.push(192 | n >> 6, 128 | 63 & n);\n              } else if (65536 > n) {\n                if (0 > (t -= 3)) break;\n                o.push(224 | n >> 12, 128 | 63 & n >> 6, 128 | 63 & n);\n              } else if (1114112 > n) {\n                if (0 > (t -= 4)) break;\n                o.push(240 | n >> 18, 128 | 63 & n >> 12, 128 | 63 & n >> 6, 128 | 63 & n);\n              } else throw new Error(\"Invalid code point\");\n            }\n            return o;\n          }\n          function Y(e) {\n            for (var t = [], n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));\n            return t;\n          }\n          function V(e, t) {\n            for (var n, r, a, o = [], d = 0; d < e.length && !(0 > (t -= 2)); ++d) n = e.charCodeAt(d), r = n >> 8, a = n % 256, o.push(a), o.push(r);\n            return o;\n          }\n          function z(e) {\n            return $.toByteArray(q(e));\n          }\n          function G(e, t, n, r) {\n            for (var a = 0; a < r && !(a + n >= t.length || a >= e.length); ++a) t[a + n] = e[a];\n            return a;\n          }\n          function K(e, t) {\n            return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name;\n          }\n          function X(e) {\n            return e !== e;\n          }\n          var $ = e(\"base64-js\"),\n            J = e(\"ieee754\");\n          n.Buffer = s, n.SlowBuffer = function (e) {\n            return +e != e && (e = 0), s.alloc(+e);\n          }, n.INSPECT_MAX_BYTES = 50;\n          n.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function () {\n            try {\n              var e = new Uint8Array(1);\n              return e.__proto__ = {\n                __proto__: Uint8Array.prototype,\n                foo: function () {\n                  return 42;\n                }\n              }, 42 === e.foo();\n            } catch (t) {\n              return !1;\n            }\n          }(), s.TYPED_ARRAY_SUPPORT || \"undefined\" == typeof console || \"function\" != typeof console.error || console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"), Object.defineProperty(s.prototype, \"parent\", {\n            enumerable: !0,\n            get: function () {\n              return s.isBuffer(this) ? this.buffer : void 0;\n            }\n          }), Object.defineProperty(s.prototype, \"offset\", {\n            enumerable: !0,\n            get: function () {\n              return s.isBuffer(this) ? this.byteOffset : void 0;\n            }\n          }), \"undefined\" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, {\n            value: null,\n            configurable: !0,\n            enumerable: !1,\n            writable: !1\n          }), s.poolSize = 8192, s.from = function (e, t, n) {\n            return l(e, t, n);\n          }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function (e, t, n) {\n            return u(e, t, n);\n          }, s.allocUnsafe = function (e) {\n            return p(e);\n          }, s.allocUnsafeSlow = function (e) {\n            return p(e);\n          }, s.isBuffer = function (e) {\n            return null != e && !0 === e._isBuffer && e !== s.prototype;\n          }, s.compare = function (e, t) {\n            if (K(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), K(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError(\"The \\\"buf1\\\", \\\"buf2\\\" arguments must be one of type Buffer or Uint8Array\");\n            if (e === t) return 0;\n            for (var n = e.length, r = t.length, d = 0, l = o(n, r); d < l; ++d) if (e[d] !== t[d]) {\n              n = e[d], r = t[d];\n              break;\n            }\n            return n < r ? -1 : r < n ? 1 : 0;\n          }, s.isEncoding = function (e) {\n            switch ((e + \"\").toLowerCase()) {\n              case \"hex\":\n              case \"utf8\":\n              case \"utf-8\":\n              case \"ascii\":\n              case \"latin1\":\n              case \"binary\":\n              case \"base64\":\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return !0;\n              default:\n                return !1;\n            }\n          }, s.concat = function (e, t) {\n            if (!Array.isArray(e)) throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");\n            if (0 === e.length) return s.alloc(0);\n            var n;\n            if (t === void 0) for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;\n            var r = s.allocUnsafe(t),\n              a = 0;\n            for (n = 0; n < e.length; ++n) {\n              var o = e[n];\n              if (K(o, Uint8Array) && (o = s.from(o)), !s.isBuffer(o)) throw new TypeError(\"\\\"list\\\" argument must be an Array of Buffers\");\n              o.copy(r, a), a += o.length;\n            }\n            return r;\n          }, s.byteLength = b, s.prototype._isBuffer = !0, s.prototype.swap16 = function () {\n            var e = this.length;\n            if (0 != e % 2) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n            for (var t = 0; t < e; t += 2) C(this, t, t + 1);\n            return this;\n          }, s.prototype.swap32 = function () {\n            var e = this.length;\n            if (0 != e % 4) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n            for (var t = 0; t < e; t += 4) C(this, t, t + 3), C(this, t + 1, t + 2);\n            return this;\n          }, s.prototype.swap64 = function () {\n            var e = this.length;\n            if (0 != e % 8) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n            for (var t = 0; t < e; t += 8) C(this, t, t + 7), C(this, t + 1, t + 6), C(this, t + 2, t + 5), C(this, t + 3, t + 4);\n            return this;\n          }, s.prototype.toString = function () {\n            var e = this.length;\n            return 0 === e ? \"\" : 0 === arguments.length ? x(this, 0, e) : y.apply(this, arguments);\n          }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function (e) {\n            if (!s.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n            return this === e || 0 === s.compare(this, e);\n          }, s.prototype.inspect = function () {\n            var e = \"\",\n              t = n.INSPECT_MAX_BYTES;\n            return e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim(), this.length > t && (e += \" ... \"), \"<Buffer \" + e + \">\";\n          }, s.prototype.compare = function (e, t, n, r, a) {\n            if (K(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError(\"The \\\"target\\\" argument must be one of type Buffer or Uint8Array. Received type \" + typeof e);\n            if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === a && (a = this.length), 0 > t || n > e.length || 0 > r || a > this.length) throw new RangeError(\"out of range index\");\n            if (r >= a && t >= n) return 0;\n            if (r >= a) return -1;\n            if (t >= n) return 1;\n            if (t >>>= 0, n >>>= 0, r >>>= 0, a >>>= 0, this === e) return 0;\n            for (var d = a - r, l = n - t, c = o(d, l), u = this.slice(r, a), p = e.slice(t, n), f = 0; f < c; ++f) if (u[f] !== p[f]) {\n              d = u[f], l = p[f];\n              break;\n            }\n            return d < l ? -1 : l < d ? 1 : 0;\n          }, s.prototype.includes = function (e, t, n) {\n            return -1 !== this.indexOf(e, t, n);\n          }, s.prototype.indexOf = function (e, t, n) {\n            return R(this, e, t, n, !0);\n          }, s.prototype.lastIndexOf = function (e, t, n) {\n            return R(this, e, t, n, !1);\n          }, s.prototype.write = function (e, t, n, r) {\n            if (void 0 === t) r = \"utf8\", n = this.length, t = 0;else if (void 0 === n && \"string\" == typeof t) r = t, n = this.length, t = 0;else if (isFinite(t)) t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = \"utf8\")) : (r = n, n = void 0);else throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n            var a = this.length - t;\n            if ((void 0 === n || n > a) && (n = a), 0 < e.length && (0 > n || 0 > t) || t > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n            r || (r = \"utf8\");\n            for (var o = !1;;) switch (r) {\n              case \"hex\":\n                return w(this, e, t, n);\n              case \"utf8\":\n              case \"utf-8\":\n                return S(this, e, t, n);\n              case \"ascii\":\n                return T(this, e, t, n);\n              case \"latin1\":\n              case \"binary\":\n                return v(this, e, t, n);\n              case \"base64\":\n                return k(this, e, t, n);\n              case \"ucs2\":\n              case \"ucs-2\":\n              case \"utf16le\":\n              case \"utf-16le\":\n                return L(this, e, t, n);\n              default:\n                if (o) throw new TypeError(\"Unknown encoding: \" + r);\n                r = (\"\" + r).toLowerCase(), o = !0;\n            }\n          }, s.prototype.toJSON = function () {\n            return {\n              type: \"Buffer\",\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n          s.prototype.slice = function (e, t) {\n            var n = this.length;\n            e = ~~e, t = t === void 0 ? n : ~~t, 0 > e ? (e += n, 0 > e && (e = 0)) : e > n && (e = n), 0 > t ? (t += n, 0 > t && (t = 0)) : t > n && (t = n), t < e && (t = e);\n            var r = this.subarray(e, t);\n            return r.__proto__ = s.prototype, r;\n          }, s.prototype.readUIntLE = function (e, t, n) {\n            e >>>= 0, t >>>= 0, n || O(e, t, this.length);\n            for (var r = this[e], a = 1, o = 0; ++o < t && (a *= 256);) r += this[e + o] * a;\n            return r;\n          }, s.prototype.readUIntBE = function (e, t, n) {\n            e >>>= 0, t >>>= 0, n || O(e, t, this.length);\n            for (var r = this[e + --t], a = 1; 0 < t && (a *= 256);) r += this[e + --t] * a;\n            return r;\n          }, s.prototype.readUInt8 = function (e, t) {\n            return e >>>= 0, t || O(e, 1, this.length), this[e];\n          }, s.prototype.readUInt16LE = function (e, t) {\n            return e >>>= 0, t || O(e, 2, this.length), this[e] | this[e + 1] << 8;\n          }, s.prototype.readUInt16BE = function (e, t) {\n            return e >>>= 0, t || O(e, 2, this.length), this[e] << 8 | this[e + 1];\n          }, s.prototype.readUInt32LE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];\n          }, s.prototype.readUInt32BE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n          }, s.prototype.readIntLE = function (e, t, n) {\n            e >>>= 0, t >>>= 0, n || O(e, t, this.length);\n            for (var a = this[e], o = 1, d = 0; ++d < t && (o *= 256);) a += this[e + d] * o;\n            return o *= 128, a >= o && (a -= r(2, 8 * t)), a;\n          }, s.prototype.readIntBE = function (e, t, n) {\n            e >>>= 0, t >>>= 0, n || O(e, t, this.length);\n            for (var a = t, o = 1, d = this[e + --a]; 0 < a && (o *= 256);) d += this[e + --a] * o;\n            return o *= 128, d >= o && (d -= r(2, 8 * t)), d;\n          }, s.prototype.readInt8 = function (e, t) {\n            return e >>>= 0, t || O(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];\n          }, s.prototype.readInt16LE = function (e, t) {\n            e >>>= 0, t || O(e, 2, this.length);\n            var n = this[e] | this[e + 1] << 8;\n            return 32768 & n ? 4294901760 | n : n;\n          }, s.prototype.readInt16BE = function (e, t) {\n            e >>>= 0, t || O(e, 2, this.length);\n            var n = this[e + 1] | this[e] << 8;\n            return 32768 & n ? 4294901760 | n : n;\n          }, s.prototype.readInt32LE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n          }, s.prototype.readInt32BE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n          }, s.prototype.readFloatLE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), J.read(this, e, !0, 23, 4);\n          }, s.prototype.readFloatBE = function (e, t) {\n            return e >>>= 0, t || O(e, 4, this.length), J.read(this, e, !1, 23, 4);\n          }, s.prototype.readDoubleLE = function (e, t) {\n            return e >>>= 0, t || O(e, 8, this.length), J.read(this, e, !0, 52, 8);\n          }, s.prototype.readDoubleBE = function (e, t) {\n            return e >>>= 0, t || O(e, 8, this.length), J.read(this, e, !1, 52, 8);\n          }, s.prototype.writeUIntLE = function (e, t, n, a) {\n            if (e = +e, t >>>= 0, n >>>= 0, !a) {\n              var o = r(2, 8 * n) - 1;\n              F(this, e, t, n, o, 0);\n            }\n            var d = 1,\n              s = 0;\n            for (this[t] = 255 & e; ++s < n && (d *= 256);) this[t + s] = 255 & e / d;\n            return t + n;\n          }, s.prototype.writeUIntBE = function (e, t, n, a) {\n            if (e = +e, t >>>= 0, n >>>= 0, !a) {\n              var o = r(2, 8 * n) - 1;\n              F(this, e, t, n, o, 0);\n            }\n            var d = n - 1,\n              s = 1;\n            for (this[t + d] = 255 & e; 0 <= --d && (s *= 256);) this[t + d] = 255 & e / s;\n            return t + n;\n          }, s.prototype.writeUInt8 = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1;\n          }, s.prototype.writeUInt16LE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;\n          }, s.prototype.writeUInt16BE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;\n          }, s.prototype.writeUInt32LE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4;\n          }, s.prototype.writeUInt32BE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;\n          }, s.prototype.writeIntLE = function (e, t, n, a) {\n            if (e = +e, t >>>= 0, !a) {\n              var o = r(2, 8 * n - 1);\n              F(this, e, t, n, o - 1, -o);\n            }\n            var d = 0,\n              s = 1,\n              l = 0;\n            for (this[t] = 255 & e; ++d < n && (s *= 256);) 0 > e && 0 === l && 0 !== this[t + d - 1] && (l = 1), this[t + d] = 255 & (e / s >> 0) - l;\n            return t + n;\n          }, s.prototype.writeIntBE = function (e, t, n, a) {\n            if (e = +e, t >>>= 0, !a) {\n              var o = r(2, 8 * n - 1);\n              F(this, e, t, n, o - 1, -o);\n            }\n            var d = n - 1,\n              s = 1,\n              l = 0;\n            for (this[t + d] = 255 & e; 0 <= --d && (s *= 256);) 0 > e && 0 === l && 0 !== this[t + d + 1] && (l = 1), this[t + d] = 255 & (e / s >> 0) - l;\n            return t + n;\n          }, s.prototype.writeInt8 = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 1, 127, -128), 0 > e && (e = 255 + e + 1), this[t] = 255 & e, t + 1;\n          }, s.prototype.writeInt16LE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2;\n          }, s.prototype.writeInt16BE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2;\n          }, s.prototype.writeInt32LE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;\n          }, s.prototype.writeInt32BE = function (e, t, n) {\n            return e = +e, t >>>= 0, n || F(this, e, t, 4, 2147483647, -2147483648), 0 > e && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4;\n          }, s.prototype.writeFloatLE = function (e, t, n) {\n            return U(this, e, t, !0, n);\n          }, s.prototype.writeFloatBE = function (e, t, n) {\n            return U(this, e, t, !1, n);\n          }, s.prototype.writeDoubleLE = function (e, t, n) {\n            return j(this, e, t, !0, n);\n          }, s.prototype.writeDoubleBE = function (e, t, n) {\n            return j(this, e, t, !1, n);\n          }, s.prototype.copy = function (e, t, n, r) {\n            if (!s.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n            if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), 0 < r && r < n && (r = n), r === n) return 0;\n            if (0 === e.length || 0 === this.length) return 0;\n            if (0 > t) throw new RangeError(\"targetStart out of bounds\");\n            if (0 > n || n >= this.length) throw new RangeError(\"Index out of range\");\n            if (0 > r) throw new RangeError(\"sourceEnd out of bounds\");\n            r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);\n            var a = r - n;\n            if (this === e && \"function\" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(t, n, r);else if (this === e && n < t && t < r) for (var o = a - 1; 0 <= o; --o) e[o + t] = this[o + n];else Uint8Array.prototype.set.call(e, this.subarray(n, r), t);\n            return a;\n          }, s.prototype.fill = function (e, t, n, r) {\n            if (\"string\" == typeof e) {\n              if (\"string\" == typeof t ? (r = t, t = 0, n = this.length) : \"string\" == typeof n && (r = n, n = this.length), void 0 !== r && \"string\" != typeof r) throw new TypeError(\"encoding must be a string\");\n              if (\"string\" == typeof r && !s.isEncoding(r)) throw new TypeError(\"Unknown encoding: \" + r);\n              if (1 === e.length) {\n                var a = e.charCodeAt(0);\n                (\"utf8\" === r && 128 > a || \"latin1\" === r) && (e = a);\n              }\n            } else \"number\" == typeof e && (e &= 255);\n            if (0 > t || this.length < t || this.length < n) throw new RangeError(\"Out of range index\");\n            if (n <= t) return this;\n            t >>>= 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);\n            var o;\n            if (\"number\" == typeof e) for (o = t; o < n; ++o) this[o] = e;else {\n              var d = s.isBuffer(e) ? e : s.from(e, r),\n                l = d.length;\n              if (0 === l) throw new TypeError(\"The value \\\"\" + e + \"\\\" is invalid for argument \\\"value\\\"\");\n              for (o = 0; o < n - t; ++o) this[o + t] = d[o % l];\n            }\n            return this;\n          };\n          var Q = /[^+/0-9A-Za-z-_]/g;\n        }).call(this);\n      }).call(this, e(\"buffer\").Buffer);\n    }, {\n      \"base64-js\": 1,\n      buffer: 3,\n      ieee754: 9\n    }],\n    4: [function (e, t, n) {\n      (function (a) {\n        (function () {\n          function r() {\n            let e;\n            try {\n              e = n.storage.getItem(\"debug\");\n            } catch (e) {}\n            return !e && \"undefined\" != typeof a && \"env\" in a && (e = a.env.DEBUG), e;\n          }\n          n.formatArgs = function (e) {\n            if (e[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + e[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + t.exports.humanize(this.diff), !this.useColors) return;\n            const n = \"color: \" + this.color;\n            e.splice(1, 0, n, \"color: inherit\");\n            let r = 0,\n              a = 0;\n            e[0].replace(/%[a-zA-Z%]/g, e => {\n              \"%%\" === e || (r++, \"%c\" === e && (a = r));\n            }), e.splice(a, 0, n);\n          }, n.save = function (e) {\n            try {\n              e ? n.storage.setItem(\"debug\", e) : n.storage.removeItem(\"debug\");\n            } catch (e) {}\n          }, n.load = r, n.useColors = function () {\n            return !!(\"undefined\" != typeof window && window.process && (\"renderer\" === window.process.type || window.process.__nwjs)) || !(\"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) && (\"undefined\" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || \"undefined\" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || \"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && 31 <= parseInt(RegExp.$1, 10) || \"undefined\" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n          }, n.storage = function () {\n            try {\n              return localStorage;\n            } catch (e) {}\n          }(), n.destroy = (() => {\n            let e = !1;\n            return () => {\n              e || (e = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n            };\n          })(), n.colors = [\"#0000CC\", \"#0000FF\", \"#0033CC\", \"#0033FF\", \"#0066CC\", \"#0066FF\", \"#0099CC\", \"#0099FF\", \"#00CC00\", \"#00CC33\", \"#00CC66\", \"#00CC99\", \"#00CCCC\", \"#00CCFF\", \"#3300CC\", \"#3300FF\", \"#3333CC\", \"#3333FF\", \"#3366CC\", \"#3366FF\", \"#3399CC\", \"#3399FF\", \"#33CC00\", \"#33CC33\", \"#33CC66\", \"#33CC99\", \"#33CCCC\", \"#33CCFF\", \"#6600CC\", \"#6600FF\", \"#6633CC\", \"#6633FF\", \"#66CC00\", \"#66CC33\", \"#9900CC\", \"#9900FF\", \"#9933CC\", \"#9933FF\", \"#99CC00\", \"#99CC33\", \"#CC0000\", \"#CC0033\", \"#CC0066\", \"#CC0099\", \"#CC00CC\", \"#CC00FF\", \"#CC3300\", \"#CC3333\", \"#CC3366\", \"#CC3399\", \"#CC33CC\", \"#CC33FF\", \"#CC6600\", \"#CC6633\", \"#CC9900\", \"#CC9933\", \"#CCCC00\", \"#CCCC33\", \"#FF0000\", \"#FF0033\", \"#FF0066\", \"#FF0099\", \"#FF00CC\", \"#FF00FF\", \"#FF3300\", \"#FF3333\", \"#FF3366\", \"#FF3399\", \"#FF33CC\", \"#FF33FF\", \"#FF6600\", \"#FF6633\", \"#FF9900\", \"#FF9933\", \"#FFCC00\", \"#FFCC33\"], n.log = console.debug || console.log || (() => {}), t.exports = e(\"./common\")(n);\n          const {\n            formatters: o\n          } = t.exports;\n          o.j = function (e) {\n            try {\n              return JSON.stringify(e);\n            } catch (e) {\n              return \"[UnexpectedJSONParseError]: \" + e.message;\n            }\n          };\n        }).call(this);\n      }).call(this, e(\"_process\"));\n    }, {\n      \"./common\": 5,\n      _process: 12\n    }],\n    5: [function (e, t) {\n      t.exports = function (t) {\n        function r(e) {\n          function t(...e) {\n            if (!t.enabled) return;\n            const a = t,\n              o = +new Date(),\n              i = o - (n || o);\n            a.diff = i, a.prev = n, a.curr = o, n = o, e[0] = r.coerce(e[0]), \"string\" != typeof e[0] && e.unshift(\"%O\");\n            let d = 0;\n            e[0] = e[0].replace(/%([a-zA-Z%])/g, (t, n) => {\n              if (\"%%\" === t) return \"%\";\n              d++;\n              const o = r.formatters[n];\n              if (\"function\" == typeof o) {\n                const n = e[d];\n                t = o.call(a, n), e.splice(d, 1), d--;\n              }\n              return t;\n            }), r.formatArgs.call(a, e);\n            const s = a.log || r.log;\n            s.apply(a, e);\n          }\n          let n,\n            o = null;\n          return t.namespace = e, t.useColors = r.useColors(), t.color = r.selectColor(e), t.extend = a, t.destroy = r.destroy, Object.defineProperty(t, \"enabled\", {\n            enumerable: !0,\n            configurable: !1,\n            get: () => null === o ? r.enabled(e) : o,\n            set: e => {\n              o = e;\n            }\n          }), \"function\" == typeof r.init && r.init(t), t;\n        }\n        function a(e, t) {\n          const n = r(this.namespace + (\"undefined\" == typeof t ? \":\" : t) + e);\n          return n.log = this.log, n;\n        }\n        function o(e) {\n          return e.toString().substring(2, e.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n        }\n        return r.debug = r, r.default = r, r.coerce = function (e) {\n          return e instanceof Error ? e.stack || e.message : e;\n        }, r.disable = function () {\n          const e = [...r.names.map(o), ...r.skips.map(o).map(e => \"-\" + e)].join(\",\");\n          return r.enable(\"\"), e;\n        }, r.enable = function (e) {\n          r.save(e), r.names = [], r.skips = [];\n          let t;\n          const n = (\"string\" == typeof e ? e : \"\").split(/[\\s,]+/),\n            a = n.length;\n          for (t = 0; t < a; t++) n[t] && (e = n[t].replace(/\\*/g, \".*?\"), \"-\" === e[0] ? r.skips.push(new RegExp(\"^\" + e.substr(1) + \"$\")) : r.names.push(new RegExp(\"^\" + e + \"$\")));\n        }, r.enabled = function (e) {\n          if (\"*\" === e[e.length - 1]) return !0;\n          let t, n;\n          for (t = 0, n = r.skips.length; t < n; t++) if (r.skips[t].test(e)) return !1;\n          for (t = 0, n = r.names.length; t < n; t++) if (r.names[t].test(e)) return !0;\n          return !1;\n        }, r.humanize = e(\"ms\"), r.destroy = function () {\n          console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n        }, Object.keys(t).forEach(e => {\n          r[e] = t[e];\n        }), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function (e) {\n          let t = 0;\n          for (let n = 0; n < e.length; n++) t = (t << 5) - t + e.charCodeAt(n), t |= 0;\n          return r.colors[n(t) % r.colors.length];\n        }, r.enable(r.load()), r;\n      };\n    }, {\n      ms: 11\n    }],\n    6: [function (e, t) {\n      'use strict';\n\n      function n(e, t) {\n        for (const n in t) Object.defineProperty(e, n, {\n          value: t[n],\n          enumerable: !0,\n          configurable: !0\n        });\n        return e;\n      }\n      t.exports = function (e, t, r) {\n        if (!e || \"string\" == typeof e) throw new TypeError(\"Please pass an Error to err-code\");\n        r || (r = {}), \"object\" == typeof t && (r = t, t = \"\"), t && (r.code = t);\n        try {\n          return n(e, r);\n        } catch (t) {\n          r.message = e.message, r.stack = e.stack;\n          const a = function () {};\n          a.prototype = Object.create(Object.getPrototypeOf(e));\n          const o = n(new a(), r);\n          return o;\n        }\n      };\n    }, {}],\n    7: [function (e, t) {\n      'use strict';\n\n      function n(e) {\n        console && console.warn && console.warn(e);\n      }\n      function r() {\n        r.init.call(this);\n      }\n      function a(e) {\n        if (\"function\" != typeof e) throw new TypeError(\"The \\\"listener\\\" argument must be of type Function. Received type \" + typeof e);\n      }\n      function o(e) {\n        return void 0 === e._maxListeners ? r.defaultMaxListeners : e._maxListeners;\n      }\n      function i(e, t, r, i) {\n        var d, s, l;\n        if (a(r), s = e._events, void 0 === s ? (s = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== s.newListener && (e.emit(\"newListener\", t, r.listener ? r.listener : r), s = e._events), l = s[t]), void 0 === l) l = s[t] = r, ++e._eventsCount;else if (\"function\" == typeof l ? l = s[t] = i ? [r, l] : [l, r] : i ? l.unshift(r) : l.push(r), d = o(e), 0 < d && l.length > d && !l.warned) {\n          l.warned = !0;\n          var c = new Error(\"Possible EventEmitter memory leak detected. \" + l.length + \" \" + (t + \" listeners added. Use emitter.setMaxListeners() to increase limit\"));\n          c.name = \"MaxListenersExceededWarning\", c.emitter = e, c.type = t, c.count = l.length, n(c);\n        }\n        return e;\n      }\n      function d() {\n        if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);\n      }\n      function s(e, t, n) {\n        var r = {\n            fired: !1,\n            wrapFn: void 0,\n            target: e,\n            type: t,\n            listener: n\n          },\n          a = d.bind(r);\n        return a.listener = n, r.wrapFn = a, a;\n      }\n      function l(e, t, n) {\n        var r = e._events;\n        if (r === void 0) return [];\n        var a = r[t];\n        return void 0 === a ? [] : \"function\" == typeof a ? n ? [a.listener || a] : [a] : n ? f(a) : u(a, a.length);\n      }\n      function c(e) {\n        var t = this._events;\n        if (t !== void 0) {\n          var n = t[e];\n          if (\"function\" == typeof n) return 1;\n          if (void 0 !== n) return n.length;\n        }\n        return 0;\n      }\n      function u(e, t) {\n        for (var n = Array(t), r = 0; r < t; ++r) n[r] = e[r];\n        return n;\n      }\n      function p(e, t) {\n        for (; t + 1 < e.length; t++) e[t] = e[t + 1];\n        e.pop();\n      }\n      function f(e) {\n        for (var t = Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];\n        return t;\n      }\n      function g(e, t, n) {\n        \"function\" == typeof e.on && _(e, \"error\", t, n);\n      }\n      function _(e, t, n, r) {\n        if (\"function\" == typeof e.on) r.once ? e.once(t, n) : e.on(t, n);else if (\"function\" == typeof e.addEventListener) e.addEventListener(t, function a(o) {\n          r.once && e.removeEventListener(t, a), n(o);\n        });else throw new TypeError(\"The \\\"emitter\\\" argument must be of type EventEmitter. Received type \" + typeof e);\n      }\n      var h,\n        m = \"object\" == typeof Reflect ? Reflect : null,\n        b = m && \"function\" == typeof m.apply ? m.apply : function (e, t, n) {\n          return Function.prototype.apply.call(e, t, n);\n        };\n      h = m && \"function\" == typeof m.ownKeys ? m.ownKeys : Object.getOwnPropertySymbols ? function (e) {\n        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));\n      } : function (e) {\n        return Object.getOwnPropertyNames(e);\n      };\n      var y = Number.isNaN || function (e) {\n        return e !== e;\n      };\n      t.exports = r, t.exports.once = function (e, t) {\n        return new Promise(function (n, r) {\n          function a(n) {\n            e.removeListener(t, o), r(n);\n          }\n          function o() {\n            \"function\" == typeof e.removeListener && e.removeListener(\"error\", a), n([].slice.call(arguments));\n          }\n          _(e, t, o, {\n            once: !0\n          }), \"error\" !== t && g(e, a, {\n            once: !0\n          });\n        });\n      }, r.EventEmitter = r, r.prototype._events = void 0, r.prototype._eventsCount = 0, r.prototype._maxListeners = void 0;\n      var C = 10;\n      Object.defineProperty(r, \"defaultMaxListeners\", {\n        enumerable: !0,\n        get: function () {\n          return C;\n        },\n        set: function (e) {\n          if (\"number\" != typeof e || 0 > e || y(e)) throw new RangeError(\"The value of \\\"defaultMaxListeners\\\" is out of range. It must be a non-negative number. Received \" + e + \".\");\n          C = e;\n        }\n      }), r.init = function () {\n        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n      }, r.prototype.setMaxListeners = function (e) {\n        if (\"number\" != typeof e || 0 > e || y(e)) throw new RangeError(\"The value of \\\"n\\\" is out of range. It must be a non-negative number. Received \" + e + \".\");\n        return this._maxListeners = e, this;\n      }, r.prototype.getMaxListeners = function () {\n        return o(this);\n      }, r.prototype.emit = function (e) {\n        for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);\n        var r = \"error\" === e,\n          a = this._events;\n        if (a !== void 0) r = r && a.error === void 0;else if (!r) return !1;\n        if (r) {\n          var o;\n          if (0 < t.length && (o = t[0]), o instanceof Error) throw o;\n          var d = new Error(\"Unhandled error.\" + (o ? \" (\" + o.message + \")\" : \"\"));\n          throw d.context = o, d;\n        }\n        var s = a[e];\n        if (s === void 0) return !1;\n        if (\"function\" == typeof s) b(s, this, t);else for (var l = s.length, c = u(s, l), n = 0; n < l; ++n) b(c[n], this, t);\n        return !0;\n      }, r.prototype.addListener = function (e, t) {\n        return i(this, e, t, !1);\n      }, r.prototype.on = r.prototype.addListener, r.prototype.prependListener = function (e, t) {\n        return i(this, e, t, !0);\n      }, r.prototype.once = function (e, t) {\n        return a(t), this.on(e, s(this, e, t)), this;\n      }, r.prototype.prependOnceListener = function (e, t) {\n        return a(t), this.prependListener(e, s(this, e, t)), this;\n      }, r.prototype.removeListener = function (e, t) {\n        var n, r, o, d, s;\n        if (a(t), r = this._events, void 0 === r) return this;\n        if (n = r[e], void 0 === n) return this;\n        if (n === t || n.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit(\"removeListener\", e, n.listener || t));else if (\"function\" != typeof n) {\n          for (o = -1, d = n.length - 1; 0 <= d; d--) if (n[d] === t || n[d].listener === t) {\n            s = n[d].listener, o = d;\n            break;\n          }\n          if (0 > o) return this;\n          0 === o ? n.shift() : p(n, o), 1 === n.length && (r[e] = n[0]), void 0 !== r.removeListener && this.emit(\"removeListener\", e, s || t);\n        }\n        return this;\n      }, r.prototype.off = r.prototype.removeListener, r.prototype.removeAllListeners = function (e) {\n        var t, n, r;\n        if (n = this._events, void 0 === n) return this;\n        if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;\n        if (0 === arguments.length) {\n          var a,\n            o = Object.keys(n);\n          for (r = 0; r < o.length; ++r) a = o[r], \"removeListener\" !== a && this.removeAllListeners(a);\n          return this.removeAllListeners(\"removeListener\"), this._events = Object.create(null), this._eventsCount = 0, this;\n        }\n        if (t = n[e], \"function\" == typeof t) this.removeListener(e, t);else if (void 0 !== t) for (r = t.length - 1; 0 <= r; r--) this.removeListener(e, t[r]);\n        return this;\n      }, r.prototype.listeners = function (e) {\n        return l(this, e, !0);\n      }, r.prototype.rawListeners = function (e) {\n        return l(this, e, !1);\n      }, r.listenerCount = function (e, t) {\n        return \"function\" == typeof e.listenerCount ? e.listenerCount(t) : c.call(e, t);\n      }, r.prototype.listenerCount = c, r.prototype.eventNames = function () {\n        return 0 < this._eventsCount ? h(this._events) : [];\n      };\n    }, {}],\n    8: [function (e, t) {\n      t.exports = function () {\n        if (\"undefined\" == typeof globalThis) return null;\n        var e = {\n          RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,\n          RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,\n          RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate\n        };\n        return e.RTCPeerConnection ? e : null;\n      };\n    }, {}],\n    9: [function (e, a, o) {\n      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */o.read = function (t, n, a, o, l) {\n        var c,\n          u,\n          p = 8 * l - o - 1,\n          f = (1 << p) - 1,\n          g = f >> 1,\n          _ = -7,\n          h = a ? l - 1 : 0,\n          b = a ? -1 : 1,\n          d = t[n + h];\n        for (h += b, c = d & (1 << -_) - 1, d >>= -_, _ += p; 0 < _; c = 256 * c + t[n + h], h += b, _ -= 8);\n        for (u = c & (1 << -_) - 1, c >>= -_, _ += o; 0 < _; u = 256 * u + t[n + h], h += b, _ -= 8);\n        if (0 === c) c = 1 - g;else {\n          if (c === f) return u ? NaN : (d ? -1 : 1) * (1 / 0);\n          u += r(2, o), c -= g;\n        }\n        return (d ? -1 : 1) * u * r(2, c - o);\n      }, o.write = function (a, o, l, u, p, f) {\n        var h,\n          b,\n          y,\n          g = Math.LN2,\n          _ = Math.log,\n          C = 8 * f - p - 1,\n          R = (1 << C) - 1,\n          E = R >> 1,\n          w = 23 === p ? r(2, -24) - r(2, -77) : 0,\n          S = u ? 0 : f - 1,\n          T = u ? 1 : -1,\n          d = 0 > o || 0 === o && 0 > 1 / o ? 1 : 0;\n        for (o = n(o), isNaN(o) || o === 1 / 0 ? (b = isNaN(o) ? 1 : 0, h = R) : (h = t(_(o) / g), 1 > o * (y = r(2, -h)) && (h--, y *= 2), o += 1 <= h + E ? w / y : w * r(2, 1 - E), 2 <= o * y && (h++, y /= 2), h + E >= R ? (b = 0, h = R) : 1 <= h + E ? (b = (o * y - 1) * r(2, p), h += E) : (b = o * r(2, E - 1) * r(2, p), h = 0)); 8 <= p; a[l + S] = 255 & b, S += T, b /= 256, p -= 8);\n        for (h = h << p | b, C += p; 0 < C; a[l + S] = 255 & h, S += T, h /= 256, C -= 8);\n        a[l + S - T] |= 128 * d;\n      };\n    }, {}],\n    10: [function (e, t) {\n      t.exports = \"function\" == typeof Object.create ? function (e, t) {\n        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {\n          constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n          }\n        }));\n      } : function (e, t) {\n        if (t) {\n          e.super_ = t;\n          var n = function () {};\n          n.prototype = t.prototype, e.prototype = new n(), e.prototype.constructor = e;\n        }\n      };\n    }, {}],\n    11: [function (e, t) {\n      var r = Math.round;\n      function a(e) {\n        if (e += \"\", !(100 < e.length)) {\n          var t = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);\n          if (t) {\n            var r = parseFloat(t[1]),\n              n = (t[2] || \"ms\").toLowerCase();\n            return \"years\" === n || \"year\" === n || \"yrs\" === n || \"yr\" === n || \"y\" === n ? 31557600000 * r : \"weeks\" === n || \"week\" === n || \"w\" === n ? 604800000 * r : \"days\" === n || \"day\" === n || \"d\" === n ? 86400000 * r : \"hours\" === n || \"hour\" === n || \"hrs\" === n || \"hr\" === n || \"h\" === n ? 3600000 * r : \"minutes\" === n || \"minute\" === n || \"mins\" === n || \"min\" === n || \"m\" === n ? 60000 * r : \"seconds\" === n || \"second\" === n || \"secs\" === n || \"sec\" === n || \"s\" === n ? 1000 * r : \"milliseconds\" === n || \"millisecond\" === n || \"msecs\" === n || \"msec\" === n || \"ms\" === n ? r : void 0;\n          }\n        }\n      }\n      function o(e) {\n        var t = n(e);\n        return 86400000 <= t ? r(e / 86400000) + \"d\" : 3600000 <= t ? r(e / 3600000) + \"h\" : 60000 <= t ? r(e / 60000) + \"m\" : 1000 <= t ? r(e / 1000) + \"s\" : e + \"ms\";\n      }\n      function i(e) {\n        var t = n(e);\n        return 86400000 <= t ? s(e, t, 86400000, \"day\") : 3600000 <= t ? s(e, t, 3600000, \"hour\") : 60000 <= t ? s(e, t, 60000, \"minute\") : 1000 <= t ? s(e, t, 1000, \"second\") : e + \" ms\";\n      }\n      function s(e, t, a, n) {\n        return r(e / a) + \" \" + n + (t >= 1.5 * a ? \"s\" : \"\");\n      }\n      var l = 24 * (60 * 60000);\n      t.exports = function (e, t) {\n        t = t || {};\n        var n = typeof e;\n        if (\"string\" == n && 0 < e.length) return a(e);\n        if (\"number\" === n && isFinite(e)) return t.long ? i(e) : o(e);\n        throw new Error(\"val is not a non-empty string or a valid number. val=\" + JSON.stringify(e));\n      };\n    }, {}],\n    12: [function (e, t) {\n      function n() {\n        throw new Error(\"setTimeout has not been defined\");\n      }\n      function r() {\n        throw new Error(\"clearTimeout has not been defined\");\n      }\n      function a(t) {\n        if (c === setTimeout) return setTimeout(t, 0);\n        if ((c === n || !c) && setTimeout) return c = setTimeout, setTimeout(t, 0);\n        try {\n          return c(t, 0);\n        } catch (n) {\n          try {\n            return c.call(null, t, 0);\n          } catch (n) {\n            return c.call(this, t, 0);\n          }\n        }\n      }\n      function o(t) {\n        if (u === clearTimeout) return clearTimeout(t);\n        if ((u === r || !u) && clearTimeout) return u = clearTimeout, clearTimeout(t);\n        try {\n          return u(t);\n        } catch (n) {\n          try {\n            return u.call(null, t);\n          } catch (n) {\n            return u.call(this, t);\n          }\n        }\n      }\n      function i() {\n        _ && f && (_ = !1, f.length ? g = f.concat(g) : h = -1, g.length && d());\n      }\n      function d() {\n        if (!_) {\n          var e = a(i);\n          _ = !0;\n          for (var t = g.length; t;) {\n            for (f = g, g = []; ++h < t;) f && f[h].run();\n            h = -1, t = g.length;\n          }\n          f = null, _ = !1, o(e);\n        }\n      }\n      function s(e, t) {\n        this.fun = e, this.array = t;\n      }\n      function l() {}\n      var c,\n        u,\n        p = t.exports = {};\n      (function () {\n        try {\n          c = \"function\" == typeof setTimeout ? setTimeout : n;\n        } catch (t) {\n          c = n;\n        }\n        try {\n          u = \"function\" == typeof clearTimeout ? clearTimeout : r;\n        } catch (t) {\n          u = r;\n        }\n      })();\n      var f,\n        g = [],\n        _ = !1,\n        h = -1;\n      p.nextTick = function (e) {\n        var t = Array(arguments.length - 1);\n        if (1 < arguments.length) for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];\n        g.push(new s(e, t)), 1 !== g.length || _ || a(d);\n      }, s.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      }, p.title = \"browser\", p.browser = !0, p.env = {}, p.argv = [], p.version = \"\", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function () {\n        return [];\n      }, p.binding = function () {\n        throw new Error(\"process.binding is not supported\");\n      }, p.cwd = function () {\n        return \"/\";\n      }, p.chdir = function () {\n        throw new Error(\"process.chdir is not supported\");\n      }, p.umask = function () {\n        return 0;\n      };\n    }, {}],\n    13: [function (e, t) {\n      (function (e) {\n        (function () {\n          /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */let n;\n          t.exports = \"function\" == typeof queueMicrotask ? queueMicrotask.bind(\"undefined\" == typeof window ? e : window) : e => (n || (n = Promise.resolve())).then(e).catch(e => setTimeout(() => {\n            throw e;\n          }, 0));\n        }).call(this);\n      }).call(this, \"undefined\" == typeof global ? \"undefined\" == typeof self ? \"undefined\" == typeof window ? {} : window : self : global);\n    }, {}],\n    14: [function (e, t) {\n      (function (n, r) {\n        (function () {\n          'use strict';\n\n          var a = e(\"safe-buffer\").Buffer,\n            o = r.crypto || r.msCrypto;\n          t.exports = o && o.getRandomValues ? function (e, t) {\n            if (e > 4294967295) throw new RangeError(\"requested too many random bytes\");\n            var r = a.allocUnsafe(e);\n            if (0 < e) if (65536 < e) for (var i = 0; i < e; i += 65536) o.getRandomValues(r.slice(i, i + 65536));else o.getRandomValues(r);\n            return \"function\" == typeof t ? n.nextTick(function () {\n              t(null, r);\n            }) : r;\n          } : function () {\n            throw new Error(\"Secure random number generation is not supported by this browser.\\nUse Chrome, Firefox or Internet Explorer 11\");\n          };\n        }).call(this);\n      }).call(this, e(\"_process\"), \"undefined\" == typeof global ? \"undefined\" == typeof self ? \"undefined\" == typeof window ? {} : window : self : global);\n    }, {\n      _process: 12,\n      \"safe-buffer\": 30\n    }],\n    15: [function (e, t) {\n      'use strict';\n\n      function n(e, t) {\n        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;\n      }\n      function r(e, t, r) {\n        function a(e, n, r) {\n          return \"string\" == typeof t ? t : t(e, n, r);\n        }\n        r || (r = Error);\n        var o = function (e) {\n          function t(t, n, r) {\n            return e.call(this, a(t, n, r)) || this;\n          }\n          return n(t, e), t;\n        }(r);\n        o.prototype.name = r.name, o.prototype.code = e, s[e] = o;\n      }\n      function a(e, t) {\n        if (Array.isArray(e)) {\n          var n = e.length;\n          return e = e.map(function (e) {\n            return e + \"\";\n          }), 2 < n ? \"one of \".concat(t, \" \").concat(e.slice(0, n - 1).join(\", \"), \", or \") + e[n - 1] : 2 === n ? \"one of \".concat(t, \" \").concat(e[0], \" or \").concat(e[1]) : \"of \".concat(t, \" \").concat(e[0]);\n        }\n        return \"of \".concat(t, \" \").concat(e + \"\");\n      }\n      function o(e, t, n) {\n        return e.substr(!n || 0 > n ? 0 : +n, t.length) === t;\n      }\n      function i(e, t, n) {\n        return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t;\n      }\n      function d(e, t, n) {\n        return \"number\" != typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n);\n      }\n      var s = {};\n      r(\"ERR_INVALID_OPT_VALUE\", function (e, t) {\n        return \"The value \\\"\" + t + \"\\\" is invalid for option \\\"\" + e + \"\\\"\";\n      }, TypeError), r(\"ERR_INVALID_ARG_TYPE\", function (e, t, n) {\n        var r;\n        \"string\" == typeof t && o(t, \"not \") ? (r = \"must not be\", t = t.replace(/^not /, \"\")) : r = \"must be\";\n        var s;\n        if (i(e, \" argument\")) s = \"The \".concat(e, \" \").concat(r, \" \").concat(a(t, \"type\"));else {\n          var l = d(e, \".\") ? \"property\" : \"argument\";\n          s = \"The \\\"\".concat(e, \"\\\" \").concat(l, \" \").concat(r, \" \").concat(a(t, \"type\"));\n        }\n        return s += \". Received type \".concat(typeof n), s;\n      }, TypeError), r(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\"), r(\"ERR_METHOD_NOT_IMPLEMENTED\", function (e) {\n        return \"The \" + e + \" method is not implemented\";\n      }), r(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\"), r(\"ERR_STREAM_DESTROYED\", function (e) {\n        return \"Cannot call \" + e + \" after a stream was destroyed\";\n      }), r(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\"), r(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\"), r(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\"), r(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError), r(\"ERR_UNKNOWN_ENCODING\", function (e) {\n        return \"Unknown encoding: \" + e;\n      }, TypeError), r(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\"), t.exports.codes = s;\n    }, {}],\n    16: [function (e, t) {\n      (function (n) {\n        (function () {\n          'use strict';\n\n          function r(e) {\n            return this instanceof r ? void (d.call(this, e), s.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once(\"end\", a)))) : new r(e);\n          }\n          function a() {\n            this._writableState.ended || n.nextTick(o, this);\n          }\n          function o(e) {\n            e.end();\n          }\n          var i = Object.keys || function (e) {\n            var t = [];\n            for (var n in e) t.push(n);\n            return t;\n          };\n          t.exports = r;\n          var d = e(\"./_stream_readable\"),\n            s = e(\"./_stream_writable\");\n          e(\"inherits\")(r, d);\n          for (var l, c = i(s.prototype), u = 0; u < c.length; u++) l = c[u], r.prototype[l] || (r.prototype[l] = s.prototype[l]);\n          Object.defineProperty(r.prototype, \"writableHighWaterMark\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState.highWaterMark;\n            }\n          }), Object.defineProperty(r.prototype, \"writableBuffer\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          }), Object.defineProperty(r.prototype, \"writableLength\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState.length;\n            }\n          }), Object.defineProperty(r.prototype, \"destroyed\", {\n            enumerable: !1,\n            get: function () {\n              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;\n            },\n            set: function (e) {\n              void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e, this._writableState.destroyed = e);\n            }\n          });\n        }).call(this);\n      }).call(this, e(\"_process\"));\n    }, {\n      \"./_stream_readable\": 18,\n      \"./_stream_writable\": 20,\n      _process: 12,\n      inherits: 10\n    }],\n    17: [function (e, t) {\n      'use strict';\n\n      function n(e) {\n        return this instanceof n ? void r.call(this, e) : new n(e);\n      }\n      t.exports = n;\n      var r = e(\"./_stream_transform\");\n      e(\"inherits\")(n, r), n.prototype._transform = function (e, t, n) {\n        n(null, e);\n      };\n    }, {\n      \"./_stream_transform\": 19,\n      inherits: 10\n    }],\n    18: [function (e, t) {\n      (function (n, r) {\n        (function () {\n          'use strict';\n\n          function a(e) {\n            return P.from(e);\n          }\n          function o(e) {\n            return P.isBuffer(e) || e instanceof M;\n          }\n          function i(e, t, n) {\n            return \"function\" == typeof e.prependListener ? e.prependListener(t, n) : void (e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [n, e._events[t]] : e.on(t, n));\n          }\n          function d(t, n, r) {\n            A = A || e(\"./_stream_duplex\"), t = t || {}, \"boolean\" != typeof r && (r = n instanceof A), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = H(this, t, \"readableHighWaterMark\", r), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || \"utf8\", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (!F && (F = e(\"string_decoder/\").StringDecoder), this.decoder = new F(t.encoding), this.encoding = t.encoding);\n          }\n          function s(t) {\n            if (A = A || e(\"./_stream_duplex\"), !(this instanceof s)) return new s(t);\n            var n = this instanceof A;\n            this._readableState = new d(t, this, n), this.readable = !0, t && (\"function\" == typeof t.read && (this._read = t.read), \"function\" == typeof t.destroy && (this._destroy = t.destroy)), I.call(this);\n          }\n          function l(e, t, n, r, o) {\n            x(\"readableAddChunk\", t);\n            var i = e._readableState;\n            if (null === t) i.reading = !1, g(e, i);else {\n              var d;\n              if (o || (d = u(i, t)), d) X(e, d);else if (!(i.objectMode || t && 0 < t.length)) r || (i.reading = !1, m(e, i));else if (\"string\" == typeof t || i.objectMode || Object.getPrototypeOf(t) === P.prototype || (t = a(t)), r) i.endEmitted ? X(e, new K()) : c(e, i, t, !0);else if (i.ended) X(e, new z());else {\n                if (i.destroyed) return !1;\n                i.reading = !1, i.decoder && !n ? (t = i.decoder.write(t), i.objectMode || 0 !== t.length ? c(e, i, t, !1) : m(e, i)) : c(e, i, t, !1);\n              }\n            }\n            return !i.ended && (i.length < i.highWaterMark || 0 === i.length);\n          }\n          function c(e, t, n, r) {\n            t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit(\"data\", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && _(e)), m(e, t);\n          }\n          function u(e, t) {\n            var n;\n            return o(t) || \"string\" == typeof t || void 0 === t || e.objectMode || (n = new V(\"chunk\", [\"string\", \"Buffer\", \"Uint8Array\"], t)), n;\n          }\n          function p(e) {\n            return 1073741824 <= e ? e = 1073741824 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;\n          }\n          function f(e, t) {\n            return 0 >= e || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e === e ? (e > t.highWaterMark && (t.highWaterMark = p(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0)) : t.flowing && t.length ? t.buffer.head.data.length : t.length;\n          }\n          function g(e, t) {\n            if (x(\"onEofChunk\"), !t.ended) {\n              if (t.decoder) {\n                var n = t.decoder.end();\n                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);\n              }\n              t.ended = !0, t.sync ? _(e) : (t.needReadable = !1, !t.emittedReadable && (t.emittedReadable = !0, h(e)));\n            }\n          }\n          function _(e) {\n            var t = e._readableState;\n            x(\"emitReadable\", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (x(\"emitReadable\", t.flowing), t.emittedReadable = !0, n.nextTick(h, e));\n          }\n          function h(e) {\n            var t = e._readableState;\n            x(\"emitReadable_\", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit(\"readable\"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, S(e);\n          }\n          function m(e, t) {\n            t.readingMore || (t.readingMore = !0, n.nextTick(b, e, t));\n          }\n          function b(e, t) {\n            for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {\n              var n = t.length;\n              if (x(\"maybeReadMore read 0\"), e.read(0), n === t.length) break;\n            }\n            t.readingMore = !1;\n          }\n          function y(e) {\n            return function () {\n              var t = e._readableState;\n              x(\"pipeOnDrain\", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && D(e, \"data\") && (t.flowing = !0, S(e));\n            };\n          }\n          function C(e) {\n            var t = e._readableState;\n            t.readableListening = 0 < e.listenerCount(\"readable\"), t.resumeScheduled && !t.paused ? t.flowing = !0 : 0 < e.listenerCount(\"data\") && e.resume();\n          }\n          function R(e) {\n            x(\"readable nexttick read 0\"), e.read(0);\n          }\n          function E(e, t) {\n            t.resumeScheduled || (t.resumeScheduled = !0, n.nextTick(w, e, t));\n          }\n          function w(e, t) {\n            x(\"resume\", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit(\"resume\"), S(e), t.flowing && !t.reading && e.read(0);\n          }\n          function S(e) {\n            var t = e._readableState;\n            for (x(\"flow\", t.flowing); t.flowing && null !== e.read(););\n          }\n          function T(e, t) {\n            if (0 === t.length) return null;\n            var n;\n            return t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join(\"\") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n;\n          }\n          function v(e) {\n            var t = e._readableState;\n            x(\"endReadable\", t.endEmitted), t.endEmitted || (t.ended = !0, n.nextTick(k, t, e));\n          }\n          function k(e, t) {\n            if (x(\"endReadableNT\", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit(\"end\"), e.autoDestroy)) {\n              var n = t._writableState;\n              (!n || n.autoDestroy && n.finished) && t.destroy();\n            }\n          }\n          function L(e, t) {\n            for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;\n            return -1;\n          }\n          t.exports = s;\n          var A;\n          s.ReadableState = d;\n          var x,\n            N = e(\"events\").EventEmitter,\n            D = function (e, t) {\n              return e.listeners(t).length;\n            },\n            I = e(\"./internal/streams/stream\"),\n            P = e(\"buffer\").Buffer,\n            M = r.Uint8Array || function () {},\n            O = e(\"util\");\n          x = O && O.debuglog ? O.debuglog(\"stream\") : function () {};\n          var F,\n            B,\n            U,\n            j = e(\"./internal/streams/buffer_list\"),\n            q = e(\"./internal/streams/destroy\"),\n            W = e(\"./internal/streams/state\"),\n            H = W.getHighWaterMark,\n            Y = e(\"../errors\").codes,\n            V = Y.ERR_INVALID_ARG_TYPE,\n            z = Y.ERR_STREAM_PUSH_AFTER_EOF,\n            G = Y.ERR_METHOD_NOT_IMPLEMENTED,\n            K = Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n          e(\"inherits\")(s, I);\n          var X = q.errorOrDestroy,\n            $ = [\"error\", \"close\", \"destroy\", \"pause\", \"resume\"];\n          Object.defineProperty(s.prototype, \"destroyed\", {\n            enumerable: !1,\n            get: function () {\n              return void 0 !== this._readableState && this._readableState.destroyed;\n            },\n            set: function (e) {\n              this._readableState && (this._readableState.destroyed = e);\n            }\n          }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function (e, t) {\n            t(e);\n          }, s.prototype.push = function (e, t) {\n            var n,\n              r = this._readableState;\n            return r.objectMode ? n = !0 : \"string\" == typeof e && (t = t || r.defaultEncoding, t !== r.encoding && (e = P.from(e, t), t = \"\"), n = !0), l(this, e, t, !1, n);\n          }, s.prototype.unshift = function (e) {\n            return l(this, e, null, !0, !1);\n          }, s.prototype.isPaused = function () {\n            return !1 === this._readableState.flowing;\n          }, s.prototype.setEncoding = function (t) {\n            F || (F = e(\"string_decoder/\").StringDecoder);\n            var n = new F(t);\n            this._readableState.decoder = n, this._readableState.encoding = this._readableState.decoder.encoding;\n            for (var r = this._readableState.buffer.head, a = \"\"; null !== r;) a += n.write(r.data), r = r.next;\n            return this._readableState.buffer.clear(), \"\" !== a && this._readableState.buffer.push(a), this._readableState.length = a.length, this;\n          };\n          s.prototype.read = function (e) {\n            x(\"read\", e), e = parseInt(e, 10);\n            var t = this._readableState,\n              r = e;\n            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 === t.highWaterMark ? 0 < t.length : t.length >= t.highWaterMark) || t.ended)) return x(\"read: emitReadable\", t.length, t.ended), 0 === t.length && t.ended ? v(this) : _(this), null;\n            if (e = f(e, t), 0 === e && t.ended) return 0 === t.length && v(this), null;\n            var a = t.needReadable;\n            x(\"need readable\", a), (0 === t.length || t.length - e < t.highWaterMark) && (a = !0, x(\"length less than watermark\", a)), t.ended || t.reading ? (a = !1, x(\"reading or ended\", a)) : a && (x(\"do read\"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, !t.reading && (e = f(r, t)));\n            var o;\n            return o = 0 < e ? T(e, t) : null, null === o ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (!t.ended && (t.needReadable = !0), r !== e && t.ended && v(this)), null !== o && this.emit(\"data\", o), o;\n          }, s.prototype._read = function () {\n            X(this, new G(\"_read()\"));\n          }, s.prototype.pipe = function (e, t) {\n            function r(e, t) {\n              x(\"onunpipe\"), e === p && t && !1 === t.hasUnpiped && (t.hasUnpiped = !0, o());\n            }\n            function a() {\n              x(\"onend\"), e.end();\n            }\n            function o() {\n              x(\"cleanup\"), e.removeListener(\"close\", l), e.removeListener(\"finish\", c), e.removeListener(\"drain\", h), e.removeListener(\"error\", s), e.removeListener(\"unpipe\", r), p.removeListener(\"end\", a), p.removeListener(\"end\", u), p.removeListener(\"data\", d), m = !0, f.awaitDrain && (!e._writableState || e._writableState.needDrain) && h();\n            }\n            function d(t) {\n              x(\"ondata\");\n              var n = e.write(t);\n              x(\"dest.write\", n), !1 === n && ((1 === f.pipesCount && f.pipes === e || 1 < f.pipesCount && -1 !== L(f.pipes, e)) && !m && (x(\"false write response, pause\", f.awaitDrain), f.awaitDrain++), p.pause());\n            }\n            function s(t) {\n              x(\"onerror\", t), u(), e.removeListener(\"error\", s), 0 === D(e, \"error\") && X(e, t);\n            }\n            function l() {\n              e.removeListener(\"finish\", c), u();\n            }\n            function c() {\n              x(\"onfinish\"), e.removeListener(\"close\", l), u();\n            }\n            function u() {\n              x(\"unpipe\"), p.unpipe(e);\n            }\n            var p = this,\n              f = this._readableState;\n            switch (f.pipesCount) {\n              case 0:\n                f.pipes = e;\n                break;\n              case 1:\n                f.pipes = [f.pipes, e];\n                break;\n              default:\n                f.pipes.push(e);\n            }\n            f.pipesCount += 1, x(\"pipe count=%d opts=%j\", f.pipesCount, t);\n            var g = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr,\n              _ = g ? a : u;\n            f.endEmitted ? n.nextTick(_) : p.once(\"end\", _), e.on(\"unpipe\", r);\n            var h = y(p);\n            e.on(\"drain\", h);\n            var m = !1;\n            return p.on(\"data\", d), i(e, \"error\", s), e.once(\"close\", l), e.once(\"finish\", c), e.emit(\"pipe\", p), f.flowing || (x(\"pipe resume\"), p.resume()), e;\n          }, s.prototype.unpipe = function (e) {\n            var t = this._readableState,\n              n = {\n                hasUnpiped: !1\n              };\n            if (0 === t.pipesCount) return this;\n            if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit(\"unpipe\", this, n), this);\n            if (!e) {\n              var r = t.pipes,\n                a = t.pipesCount;\n              t.pipes = null, t.pipesCount = 0, t.flowing = !1;\n              for (var o = 0; o < a; o++) r[o].emit(\"unpipe\", this, {\n                hasUnpiped: !1\n              });\n              return this;\n            }\n            var d = L(t.pipes, e);\n            return -1 === d ? this : (t.pipes.splice(d, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit(\"unpipe\", this, n), this);\n          }, s.prototype.on = function (e, t) {\n            var r = I.prototype.on.call(this, e, t),\n              a = this._readableState;\n            return \"data\" === e ? (a.readableListening = 0 < this.listenerCount(\"readable\"), !1 !== a.flowing && this.resume()) : \"readable\" == e && !a.endEmitted && !a.readableListening && (a.readableListening = a.needReadable = !0, a.flowing = !1, a.emittedReadable = !1, x(\"on readable\", a.length, a.reading), a.length ? _(this) : !a.reading && n.nextTick(R, this)), r;\n          }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function (e, t) {\n            var r = I.prototype.removeListener.call(this, e, t);\n            return \"readable\" === e && n.nextTick(C, this), r;\n          }, s.prototype.removeAllListeners = function (e) {\n            var t = I.prototype.removeAllListeners.apply(this, arguments);\n            return (\"readable\" === e || void 0 === e) && n.nextTick(C, this), t;\n          }, s.prototype.resume = function () {\n            var e = this._readableState;\n            return e.flowing || (x(\"resume\"), e.flowing = !e.readableListening, E(this, e)), e.paused = !1, this;\n          }, s.prototype.pause = function () {\n            return x(\"call pause flowing=%j\", this._readableState.flowing), !1 !== this._readableState.flowing && (x(\"pause\"), this._readableState.flowing = !1, this.emit(\"pause\")), this._readableState.paused = !0, this;\n          }, s.prototype.wrap = function (e) {\n            var t = this,\n              r = this._readableState,\n              a = !1;\n            for (var o in e.on(\"end\", function () {\n              if (x(\"wrapped end\"), r.decoder && !r.ended) {\n                var e = r.decoder.end();\n                e && e.length && t.push(e);\n              }\n              t.push(null);\n            }), e.on(\"data\", function (n) {\n              if ((x(\"wrapped data\"), r.decoder && (n = r.decoder.write(n)), !(r.objectMode && (null === n || void 0 === n))) && (r.objectMode || n && n.length)) {\n                var o = t.push(n);\n                o || (a = !0, e.pause());\n              }\n            }), e) void 0 === this[o] && \"function\" == typeof e[o] && (this[o] = function (t) {\n              return function () {\n                return e[t].apply(e, arguments);\n              };\n            }(o));\n            for (var i = 0; i < $.length; i++) e.on($[i], this.emit.bind(this, $[i]));\n            return this._read = function (t) {\n              x(\"wrapped _read\", t), a && (a = !1, e.resume());\n            }, this;\n          }, \"function\" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function () {\n            return void 0 === B && (B = e(\"./internal/streams/async_iterator\")), B(this);\n          }), Object.defineProperty(s.prototype, \"readableHighWaterMark\", {\n            enumerable: !1,\n            get: function () {\n              return this._readableState.highWaterMark;\n            }\n          }), Object.defineProperty(s.prototype, \"readableBuffer\", {\n            enumerable: !1,\n            get: function () {\n              return this._readableState && this._readableState.buffer;\n            }\n          }), Object.defineProperty(s.prototype, \"readableFlowing\", {\n            enumerable: !1,\n            get: function () {\n              return this._readableState.flowing;\n            },\n            set: function (e) {\n              this._readableState && (this._readableState.flowing = e);\n            }\n          }), s._fromList = T, Object.defineProperty(s.prototype, \"readableLength\", {\n            enumerable: !1,\n            get: function () {\n              return this._readableState.length;\n            }\n          }), \"function\" == typeof Symbol && (s.from = function (t, n) {\n            return void 0 === U && (U = e(\"./internal/streams/from\")), U(s, t, n);\n          });\n        }).call(this);\n      }).call(this, e(\"_process\"), \"undefined\" == typeof global ? \"undefined\" == typeof self ? \"undefined\" == typeof window ? {} : window : self : global);\n    }, {\n      \"../errors\": 15,\n      \"./_stream_duplex\": 16,\n      \"./internal/streams/async_iterator\": 21,\n      \"./internal/streams/buffer_list\": 22,\n      \"./internal/streams/destroy\": 23,\n      \"./internal/streams/from\": 25,\n      \"./internal/streams/state\": 27,\n      \"./internal/streams/stream\": 28,\n      _process: 12,\n      buffer: 3,\n      events: 7,\n      inherits: 10,\n      \"string_decoder/\": 31,\n      util: 2\n    }],\n    19: [function (e, t) {\n      'use strict';\n\n      function n(e, t) {\n        var n = this._transformState;\n        n.transforming = !1;\n        var r = n.writecb;\n        if (null === r) return this.emit(\"error\", new s());\n        n.writechunk = null, n.writecb = null, null != t && this.push(t), r(e);\n        var a = this._readableState;\n        a.reading = !1, (a.needReadable || a.length < a.highWaterMark) && this._read(a.highWaterMark);\n      }\n      function r(e) {\n        return this instanceof r ? void (u.call(this, e), this._transformState = {\n          afterTransform: n.bind(this),\n          needTransform: !1,\n          transforming: !1,\n          writecb: null,\n          writechunk: null,\n          writeencoding: null\n        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (\"function\" == typeof e.transform && (this._transform = e.transform), \"function\" == typeof e.flush && (this._flush = e.flush)), this.on(\"prefinish\", a)) : new r(e);\n      }\n      function a() {\n        var e = this;\n        \"function\" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function (t, n) {\n          o(e, t, n);\n        });\n      }\n      function o(e, t, n) {\n        if (t) return e.emit(\"error\", t);\n        if (null != n && e.push(n), e._writableState.length) throw new c();\n        if (e._transformState.transforming) throw new l();\n        return e.push(null);\n      }\n      t.exports = r;\n      var i = e(\"../errors\").codes,\n        d = i.ERR_METHOD_NOT_IMPLEMENTED,\n        s = i.ERR_MULTIPLE_CALLBACK,\n        l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n        c = i.ERR_TRANSFORM_WITH_LENGTH_0,\n        u = e(\"./_stream_duplex\");\n      e(\"inherits\")(r, u), r.prototype.push = function (e, t) {\n        return this._transformState.needTransform = !1, u.prototype.push.call(this, e, t);\n      }, r.prototype._transform = function (e, t, n) {\n        n(new d(\"_transform()\"));\n      }, r.prototype._write = function (e, t, n) {\n        var r = this._transformState;\n        if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {\n          var a = this._readableState;\n          (r.needTransform || a.needReadable || a.length < a.highWaterMark) && this._read(a.highWaterMark);\n        }\n      }, r.prototype._read = function () {\n        var e = this._transformState;\n        null === e.writechunk || e.transforming ? e.needTransform = !0 : (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform));\n      }, r.prototype._destroy = function (e, t) {\n        u.prototype._destroy.call(this, e, function (e) {\n          t(e);\n        });\n      };\n    }, {\n      \"../errors\": 15,\n      \"./_stream_duplex\": 16,\n      inherits: 10\n    }],\n    20: [function (e, t) {\n      (function (n, r) {\n        (function () {\n          'use strict';\n\n          function a(e) {\n            var t = this;\n            this.next = null, this.entry = null, this.finish = function () {\n              v(t, e);\n            };\n          }\n          function o(e) {\n            return x.from(e);\n          }\n          function i(e) {\n            return x.isBuffer(e) || e instanceof N;\n          }\n          function d() {}\n          function s(t, n, r) {\n            k = k || e(\"./_stream_duplex\"), t = t || {}, \"boolean\" != typeof r && (r = n instanceof k), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = P(this, t, \"writableHighWaterMark\", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;\n            var o = !1 === t.decodeStrings;\n            this.decodeStrings = !o, this.defaultEncoding = t.defaultEncoding || \"utf8\", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) {\n              m(n, e);\n            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);\n          }\n          function l(t) {\n            k = k || e(\"./_stream_duplex\");\n            var n = this instanceof k;\n            return n || V.call(l, this) ? void (this._writableState = new s(t, this, n), this.writable = !0, t && (\"function\" == typeof t.write && (this._write = t.write), \"function\" == typeof t.writev && (this._writev = t.writev), \"function\" == typeof t.destroy && (this._destroy = t.destroy), \"function\" == typeof t.final && (this._final = t.final)), A.call(this)) : new l(t);\n          }\n          function c(e, t) {\n            var r = new W();\n            Y(e, r), n.nextTick(t, r);\n          }\n          function u(e, t, r, a) {\n            var o;\n            return null === r ? o = new q() : \"string\" != typeof r && !t.objectMode && (o = new O(\"chunk\", [\"string\", \"Buffer\"], r)), !o || (Y(e, o), n.nextTick(a, o), !1);\n          }\n          function p(e, t, n) {\n            return e.objectMode || !1 === e.decodeStrings || \"string\" != typeof t || (t = x.from(t, n)), t;\n          }\n          function f(e, t, n, r, a, o) {\n            if (!n) {\n              var i = p(t, r, a);\n              r !== i && (n = !0, a = \"buffer\", r = i);\n            }\n            var d = t.objectMode ? 1 : r.length;\n            t.length += d;\n            var s = t.length < t.highWaterMark;\n            if (s || (t.needDrain = !0), t.writing || t.corked) {\n              var l = t.lastBufferedRequest;\n              t.lastBufferedRequest = {\n                chunk: r,\n                encoding: a,\n                isBuf: n,\n                callback: o,\n                next: null\n              }, l ? l.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;\n            } else g(e, t, !1, d, r, a, o);\n            return s;\n          }\n          function g(e, t, n, r, a, o, i) {\n            t.writelen = r, t.writecb = i, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new j(\"write\")) : n ? e._writev(a, t.onwrite) : e._write(a, o, t.onwrite), t.sync = !1;\n          }\n          function _(e, t, r, a, o) {\n            --t.pendingcb, r ? (n.nextTick(o, a), n.nextTick(S, e, t), e._writableState.errorEmitted = !0, Y(e, a)) : (o(a), e._writableState.errorEmitted = !0, Y(e, a), S(e, t));\n          }\n          function h(e) {\n            e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;\n          }\n          function m(e, t) {\n            var r = e._writableState,\n              a = r.sync,\n              o = r.writecb;\n            if (\"function\" != typeof o) throw new B();\n            if (h(r), t) _(e, r, a, t, o);else {\n              var i = R(r) || e.destroyed;\n              i || r.corked || r.bufferProcessing || !r.bufferedRequest || C(e, r), a ? n.nextTick(b, e, r, i, o) : b(e, r, i, o);\n            }\n          }\n          function b(e, t, n, r) {\n            n || y(e, t), t.pendingcb--, r(), S(e, t);\n          }\n          function y(e, t) {\n            0 === t.length && t.needDrain && (t.needDrain = !1, e.emit(\"drain\"));\n          }\n          function C(e, t) {\n            t.bufferProcessing = !0;\n            var n = t.bufferedRequest;\n            if (e._writev && n && n.next) {\n              var r = t.bufferedRequestCount,\n                o = Array(r),\n                i = t.corkedRequestsFree;\n              i.entry = n;\n              for (var d = 0, s = !0; n;) o[d] = n, n.isBuf || (s = !1), n = n.next, d += 1;\n              o.allBuffers = s, g(e, t, !0, t.length, o, \"\", i.finish), t.pendingcb++, t.lastBufferedRequest = null, i.next ? (t.corkedRequestsFree = i.next, i.next = null) : t.corkedRequestsFree = new a(t), t.bufferedRequestCount = 0;\n            } else {\n              for (; n;) {\n                var l = n.chunk,\n                  c = n.encoding,\n                  u = n.callback,\n                  p = t.objectMode ? 1 : l.length;\n                if (g(e, t, !1, p, l, c, u), n = n.next, t.bufferedRequestCount--, t.writing) break;\n              }\n              null === n && (t.lastBufferedRequest = null);\n            }\n            t.bufferedRequest = n, t.bufferProcessing = !1;\n          }\n          function R(e) {\n            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;\n          }\n          function E(e, t) {\n            e._final(function (n) {\n              t.pendingcb--, n && Y(e, n), t.prefinished = !0, e.emit(\"prefinish\"), S(e, t);\n            });\n          }\n          function w(e, t) {\n            t.prefinished || t.finalCalled || (\"function\" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit(\"prefinish\")) : (t.pendingcb++, t.finalCalled = !0, n.nextTick(E, e, t)));\n          }\n          function S(e, t) {\n            var n = R(t);\n            if (n && (w(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit(\"finish\"), t.autoDestroy))) {\n              var r = e._readableState;\n              (!r || r.autoDestroy && r.endEmitted) && e.destroy();\n            }\n            return n;\n          }\n          function T(e, t, r) {\n            t.ending = !0, S(e, t), r && (t.finished ? n.nextTick(r) : e.once(\"finish\", r)), t.ended = !0, e.writable = !1;\n          }\n          function v(e, t, n) {\n            var r = e.entry;\n            for (e.entry = null; r;) {\n              var a = r.callback;\n              t.pendingcb--, a(n), r = r.next;\n            }\n            t.corkedRequestsFree.next = e;\n          }\n          t.exports = l;\n          var k;\n          l.WritableState = s;\n          var L = {\n              deprecate: e(\"util-deprecate\")\n            },\n            A = e(\"./internal/streams/stream\"),\n            x = e(\"buffer\").Buffer,\n            N = r.Uint8Array || function () {},\n            D = e(\"./internal/streams/destroy\"),\n            I = e(\"./internal/streams/state\"),\n            P = I.getHighWaterMark,\n            M = e(\"../errors\").codes,\n            O = M.ERR_INVALID_ARG_TYPE,\n            F = M.ERR_METHOD_NOT_IMPLEMENTED,\n            B = M.ERR_MULTIPLE_CALLBACK,\n            U = M.ERR_STREAM_CANNOT_PIPE,\n            j = M.ERR_STREAM_DESTROYED,\n            q = M.ERR_STREAM_NULL_VALUES,\n            W = M.ERR_STREAM_WRITE_AFTER_END,\n            H = M.ERR_UNKNOWN_ENCODING,\n            Y = D.errorOrDestroy;\n          e(\"inherits\")(l, A), s.prototype.getBuffer = function () {\n            for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;\n            return t;\n          }, function () {\n            try {\n              Object.defineProperty(s.prototype, \"buffer\", {\n                get: L.deprecate(function () {\n                  return this.getBuffer();\n                }, \"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\", \"DEP0003\")\n              });\n            } catch (e) {}\n          }();\n          var V;\n          \"function\" == typeof Symbol && Symbol.hasInstance && \"function\" == typeof Function.prototype[Symbol.hasInstance] ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, {\n            value: function (e) {\n              return !!V.call(this, e) || !(this !== l) && e && e._writableState instanceof s;\n            }\n          })) : V = function (e) {\n            return e instanceof this;\n          }, l.prototype.pipe = function () {\n            Y(this, new U());\n          }, l.prototype.write = function (e, t, n) {\n            var r = this._writableState,\n              a = !1,\n              s = !r.objectMode && i(e);\n            return s && !x.isBuffer(e) && (e = o(e)), \"function\" == typeof t && (n = t, t = null), s ? t = \"buffer\" : !t && (t = r.defaultEncoding), \"function\" != typeof n && (n = d), r.ending ? c(this, n) : (s || u(this, r, e, n)) && (r.pendingcb++, a = f(this, r, s, e, t, n)), a;\n          }, l.prototype.cork = function () {\n            this._writableState.corked++;\n          }, l.prototype.uncork = function () {\n            var e = this._writableState;\n            e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && C(this, e));\n          }, l.prototype.setDefaultEncoding = function (e) {\n            if (\"string\" == typeof e && (e = e.toLowerCase()), !(-1 < [\"hex\", \"utf8\", \"utf-8\", \"ascii\", \"binary\", \"base64\", \"ucs2\", \"ucs-2\", \"utf16le\", \"utf-16le\", \"raw\"].indexOf((e + \"\").toLowerCase()))) throw new H(e);\n            return this._writableState.defaultEncoding = e, this;\n          }, Object.defineProperty(l.prototype, \"writableBuffer\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          }), Object.defineProperty(l.prototype, \"writableHighWaterMark\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState.highWaterMark;\n            }\n          }), l.prototype._write = function (e, t, n) {\n            n(new F(\"_write()\"));\n          }, l.prototype._writev = null, l.prototype.end = function (e, t, n) {\n            var r = this._writableState;\n            return \"function\" == typeof e ? (n = e, e = null, t = null) : \"function\" == typeof t && (n = t, t = null), null !== e && void 0 !== e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || T(this, r, n), this;\n          }, Object.defineProperty(l.prototype, \"writableLength\", {\n            enumerable: !1,\n            get: function () {\n              return this._writableState.length;\n            }\n          }), Object.defineProperty(l.prototype, \"destroyed\", {\n            enumerable: !1,\n            get: function () {\n              return void 0 !== this._writableState && this._writableState.destroyed;\n            },\n            set: function (e) {\n              this._writableState && (this._writableState.destroyed = e);\n            }\n          }), l.prototype.destroy = D.destroy, l.prototype._undestroy = D.undestroy, l.prototype._destroy = function (e, t) {\n            t(e);\n          };\n        }).call(this);\n      }).call(this, e(\"_process\"), \"undefined\" == typeof global ? \"undefined\" == typeof self ? \"undefined\" == typeof window ? {} : window : self : global);\n    }, {\n      \"../errors\": 15,\n      \"./_stream_duplex\": 16,\n      \"./internal/streams/destroy\": 23,\n      \"./internal/streams/state\": 27,\n      \"./internal/streams/stream\": 28,\n      _process: 12,\n      buffer: 3,\n      inherits: 10,\n      \"util-deprecate\": 32\n    }],\n    21: [function (e, t) {\n      (function (n) {\n        (function () {\n          'use strict';\n\n          function r(e, t, n) {\n            return t in e ? Object.defineProperty(e, t, {\n              value: n,\n              enumerable: !0,\n              configurable: !0,\n              writable: !0\n            }) : e[t] = n, e;\n          }\n          function a(e, t) {\n            return {\n              value: e,\n              done: t\n            };\n          }\n          function o(e) {\n            var t = e[c];\n            if (null !== t) {\n              var n = e[h].read();\n              null !== n && (e[g] = null, e[c] = null, e[u] = null, t(a(n, !1)));\n            }\n          }\n          function i(e) {\n            n.nextTick(o, e);\n          }\n          function d(e, t) {\n            return function (n, r) {\n              e.then(function () {\n                return t[f] ? void n(a(void 0, !0)) : void t[_](n, r);\n              }, r);\n            };\n          }\n          var s,\n            l = e(\"./end-of-stream\"),\n            c = Symbol(\"lastResolve\"),\n            u = Symbol(\"lastReject\"),\n            p = Symbol(\"error\"),\n            f = Symbol(\"ended\"),\n            g = Symbol(\"lastPromise\"),\n            _ = Symbol(\"handlePromise\"),\n            h = Symbol(\"stream\"),\n            m = Object.getPrototypeOf(function () {}),\n            b = Object.setPrototypeOf((s = {\n              get stream() {\n                return this[h];\n              },\n              next: function () {\n                var e = this,\n                  t = this[p];\n                if (null !== t) return Promise.reject(t);\n                if (this[f]) return Promise.resolve(a(void 0, !0));\n                if (this[h].destroyed) return new Promise(function (t, r) {\n                  n.nextTick(function () {\n                    e[p] ? r(e[p]) : t(a(void 0, !0));\n                  });\n                });\n                var r,\n                  o = this[g];\n                if (o) r = new Promise(d(o, this));else {\n                  var i = this[h].read();\n                  if (null !== i) return Promise.resolve(a(i, !1));\n                  r = new Promise(this[_]);\n                }\n                return this[g] = r, r;\n              }\n            }, r(s, Symbol.asyncIterator, function () {\n              return this;\n            }), r(s, \"return\", function () {\n              var e = this;\n              return new Promise(function (t, n) {\n                e[h].destroy(null, function (e) {\n                  return e ? void n(e) : void t(a(void 0, !0));\n                });\n              });\n            }), s), m);\n          t.exports = function (e) {\n            var t,\n              n = Object.create(b, (t = {}, r(t, h, {\n                value: e,\n                writable: !0\n              }), r(t, c, {\n                value: null,\n                writable: !0\n              }), r(t, u, {\n                value: null,\n                writable: !0\n              }), r(t, p, {\n                value: null,\n                writable: !0\n              }), r(t, f, {\n                value: e._readableState.endEmitted,\n                writable: !0\n              }), r(t, _, {\n                value: function (e, t) {\n                  var r = n[h].read();\n                  r ? (n[g] = null, n[c] = null, n[u] = null, e(a(r, !1))) : (n[c] = e, n[u] = t);\n                },\n                writable: !0\n              }), t));\n            return n[g] = null, l(e, function (e) {\n              if (e && \"ERR_STREAM_PREMATURE_CLOSE\" !== e.code) {\n                var t = n[u];\n                return null !== t && (n[g] = null, n[c] = null, n[u] = null, t(e)), void (n[p] = e);\n              }\n              var r = n[c];\n              null !== r && (n[g] = null, n[c] = null, n[u] = null, r(a(void 0, !0))), n[f] = !0;\n            }), e.on(\"readable\", i.bind(null, n)), n;\n          };\n        }).call(this);\n      }).call(this, e(\"_process\"));\n    }, {\n      \"./end-of-stream\": 24,\n      _process: 12\n    }],\n    22: [function (e, t) {\n      'use strict';\n\n      function n(e, t) {\n        var n = Object.keys(e);\n        if (Object.getOwnPropertySymbols) {\n          var r = Object.getOwnPropertySymbols(e);\n          t && (r = r.filter(function (t) {\n            return Object.getOwnPropertyDescriptor(e, t).enumerable;\n          })), n.push.apply(n, r);\n        }\n        return n;\n      }\n      function r(e) {\n        for (var t, r = 1; r < arguments.length; r++) t = null == arguments[r] ? {} : arguments[r], r % 2 ? n(Object(t), !0).forEach(function (n) {\n          a(e, n, t[n]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : n(Object(t)).forEach(function (n) {\n          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(t, n));\n        });\n        return e;\n      }\n      function a(e, t, n) {\n        return t in e ? Object.defineProperty(e, t, {\n          value: n,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0\n        }) : e[t] = n, e;\n      }\n      function o(e, t) {\n        if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function i(e, t) {\n        for (var n, r = 0; r < t.length; r++) n = t[r], n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(e, n.key, n);\n      }\n      function d(e, t, n) {\n        return t && i(e.prototype, t), n && i(e, n), e;\n      }\n      function s(e, t, n) {\n        u.prototype.copy.call(e, t, n);\n      }\n      var l = e(\"buffer\"),\n        u = l.Buffer,\n        p = e(\"util\"),\n        f = p.inspect,\n        g = f && f.custom || \"inspect\";\n      t.exports = function () {\n        function e() {\n          o(this, e), this.head = null, this.tail = null, this.length = 0;\n        }\n        return d(e, [{\n          key: \"push\",\n          value: function (e) {\n            var t = {\n              data: e,\n              next: null\n            };\n            0 < this.length ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;\n          }\n        }, {\n          key: \"unshift\",\n          value: function (e) {\n            var t = {\n              data: e,\n              next: this.head\n            };\n            0 === this.length && (this.tail = t), this.head = t, ++this.length;\n          }\n        }, {\n          key: \"shift\",\n          value: function () {\n            if (0 !== this.length) {\n              var e = this.head.data;\n              return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e;\n            }\n          }\n        }, {\n          key: \"clear\",\n          value: function () {\n            this.head = this.tail = null, this.length = 0;\n          }\n        }, {\n          key: \"join\",\n          value: function (e) {\n            if (0 === this.length) return \"\";\n            for (var t = this.head, n = \"\" + t.data; t = t.next;) n += e + t.data;\n            return n;\n          }\n        }, {\n          key: \"concat\",\n          value: function (e) {\n            if (0 === this.length) return u.alloc(0);\n            for (var t = u.allocUnsafe(e >>> 0), n = this.head, r = 0; n;) s(n.data, t, r), r += n.data.length, n = n.next;\n            return t;\n          }\n        }, {\n          key: \"consume\",\n          value: function (e, t) {\n            var n;\n            return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : e === this.head.data.length ? n = this.shift() : n = t ? this._getString(e) : this._getBuffer(e), n;\n          }\n        }, {\n          key: \"first\",\n          value: function () {\n            return this.head.data;\n          }\n        }, {\n          key: \"_getString\",\n          value: function (e) {\n            var t = this.head,\n              r = 1,\n              a = t.data;\n            for (e -= a.length; t = t.next;) {\n              var o = t.data,\n                i = e > o.length ? o.length : e;\n              if (a += i === o.length ? o : o.slice(0, e), e -= i, 0 === e) {\n                i === o.length ? (++r, this.head = t.next ? t.next : this.tail = null) : (this.head = t, t.data = o.slice(i));\n                break;\n              }\n              ++r;\n            }\n            return this.length -= r, a;\n          }\n        }, {\n          key: \"_getBuffer\",\n          value: function (e) {\n            var t = u.allocUnsafe(e),\n              r = this.head,\n              a = 1;\n            for (r.data.copy(t), e -= r.data.length; r = r.next;) {\n              var o = r.data,\n                i = e > o.length ? o.length : e;\n              if (o.copy(t, t.length - e, 0, i), e -= i, 0 === e) {\n                i === o.length ? (++a, this.head = r.next ? r.next : this.tail = null) : (this.head = r, r.data = o.slice(i));\n                break;\n              }\n              ++a;\n            }\n            return this.length -= a, t;\n          }\n        }, {\n          key: g,\n          value: function (e, t) {\n            return f(this, r({}, t, {\n              depth: 0,\n              customInspect: !1\n            }));\n          }\n        }]), e;\n      }();\n    }, {\n      buffer: 3,\n      util: 2\n    }],\n    23: [function (e, t) {\n      (function (e) {\n        (function () {\n          'use strict';\n\n          function n(e, t) {\n            a(e, t), r(e);\n          }\n          function r(e) {\n            e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit(\"close\");\n          }\n          function a(e, t) {\n            e.emit(\"error\", t);\n          }\n          t.exports = {\n            destroy: function (t, o) {\n              var i = this,\n                d = this._readableState && this._readableState.destroyed,\n                s = this._writableState && this._writableState.destroyed;\n              return d || s ? (o ? o(t) : t && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = !0, e.nextTick(a, this, t)) : e.nextTick(a, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function (t) {\n                !o && t ? i._writableState ? i._writableState.errorEmitted ? e.nextTick(r, i) : (i._writableState.errorEmitted = !0, e.nextTick(n, i, t)) : e.nextTick(n, i, t) : o ? (e.nextTick(r, i), o(t)) : e.nextTick(r, i);\n              }), this);\n            },\n            undestroy: function () {\n              this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);\n            },\n            errorOrDestroy: function (e, t) {\n              var n = e._readableState,\n                r = e._writableState;\n              n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit(\"error\", t);\n            }\n          };\n        }).call(this);\n      }).call(this, e(\"_process\"));\n    }, {\n      _process: 12\n    }],\n    24: [function (e, t) {\n      'use strict';\n\n      function n(e) {\n        var t = !1;\n        return function () {\n          if (!t) {\n            t = !0;\n            for (var n = arguments.length, r = Array(n), a = 0; a < n; a++) r[a] = arguments[a];\n            e.apply(this, r);\n          }\n        };\n      }\n      function r() {}\n      function a(e) {\n        return e.setHeader && \"function\" == typeof e.abort;\n      }\n      function o(e, t, d) {\n        if (\"function\" == typeof t) return o(e, null, t);\n        t || (t = {}), d = n(d || r);\n        var s = t.readable || !1 !== t.readable && e.readable,\n          l = t.writable || !1 !== t.writable && e.writable,\n          c = function () {\n            e.writable || p();\n          },\n          u = e._writableState && e._writableState.finished,\n          p = function () {\n            l = !1, u = !0, s || d.call(e);\n          },\n          f = e._readableState && e._readableState.endEmitted,\n          g = function () {\n            s = !1, f = !0, l || d.call(e);\n          },\n          _ = function (t) {\n            d.call(e, t);\n          },\n          h = function () {\n            var t;\n            return s && !f ? (e._readableState && e._readableState.ended || (t = new i()), d.call(e, t)) : l && !u ? (e._writableState && e._writableState.ended || (t = new i()), d.call(e, t)) : void 0;\n          },\n          m = function () {\n            e.req.on(\"finish\", p);\n          };\n        return a(e) ? (e.on(\"complete\", p), e.on(\"abort\", h), e.req ? m() : e.on(\"request\", m)) : l && !e._writableState && (e.on(\"end\", c), e.on(\"close\", c)), e.on(\"end\", g), e.on(\"finish\", p), !1 !== t.error && e.on(\"error\", _), e.on(\"close\", h), function () {\n          e.removeListener(\"complete\", p), e.removeListener(\"abort\", h), e.removeListener(\"request\", m), e.req && e.req.removeListener(\"finish\", p), e.removeListener(\"end\", c), e.removeListener(\"close\", c), e.removeListener(\"finish\", p), e.removeListener(\"end\", g), e.removeListener(\"error\", _), e.removeListener(\"close\", h);\n        };\n      }\n      var i = e(\"../../../errors\").codes.ERR_STREAM_PREMATURE_CLOSE;\n      t.exports = o;\n    }, {\n      \"../../../errors\": 15\n    }],\n    25: [function (e, t) {\n      t.exports = function () {\n        throw new Error(\"Readable.from is not available in the browser\");\n      };\n    }, {}],\n    26: [function (e, t) {\n      'use strict';\n\n      function n(e) {\n        var t = !1;\n        return function () {\n          t || (t = !0, e.apply(void 0, arguments));\n        };\n      }\n      function r(e) {\n        if (e) throw e;\n      }\n      function a(e) {\n        return e.setHeader && \"function\" == typeof e.abort;\n      }\n      function o(t, r, o, i) {\n        i = n(i);\n        var d = !1;\n        t.on(\"close\", function () {\n          d = !0;\n        }), l === void 0 && (l = e(\"./end-of-stream\")), l(t, {\n          readable: r,\n          writable: o\n        }, function (e) {\n          return e ? i(e) : void (d = !0, i());\n        });\n        var s = !1;\n        return function (e) {\n          if (!d) return s ? void 0 : (s = !0, a(t) ? t.abort() : \"function\" == typeof t.destroy ? t.destroy() : void i(e || new p(\"pipe\")));\n        };\n      }\n      function i(e) {\n        e();\n      }\n      function d(e, t) {\n        return e.pipe(t);\n      }\n      function s(e) {\n        return e.length ? \"function\" == typeof e[e.length - 1] ? e.pop() : r : r;\n      }\n      var l,\n        c = e(\"../../../errors\").codes,\n        u = c.ERR_MISSING_ARGS,\n        p = c.ERR_STREAM_DESTROYED;\n      t.exports = function () {\n        for (var e = arguments.length, t = Array(e), n = 0; n < e; n++) t[n] = arguments[n];\n        var r = s(t);\n        if (Array.isArray(t[0]) && (t = t[0]), 2 > t.length) throw new u(\"streams\");\n        var a,\n          l = t.map(function (e, n) {\n            var d = n < t.length - 1;\n            return o(e, d, 0 < n, function (e) {\n              a || (a = e), e && l.forEach(i), d || (l.forEach(i), r(a));\n            });\n          });\n        return t.reduce(d);\n      };\n    }, {\n      \"../../../errors\": 15,\n      \"./end-of-stream\": 24\n    }],\n    27: [function (e, n) {\n      'use strict';\n\n      function r(e, t, n) {\n        return null == e.highWaterMark ? t ? e[n] : null : e.highWaterMark;\n      }\n      var a = e(\"../../../errors\").codes.ERR_INVALID_OPT_VALUE;\n      n.exports = {\n        getHighWaterMark: function (e, n, o, i) {\n          var d = r(n, i, o);\n          if (null != d) {\n            if (!(isFinite(d) && t(d) === d) || 0 > d) {\n              var s = i ? o : \"highWaterMark\";\n              throw new a(s, d);\n            }\n            return t(d);\n          }\n          return e.objectMode ? 16 : 16384;\n        }\n      };\n    }, {\n      \"../../../errors\": 15\n    }],\n    28: [function (e, t) {\n      t.exports = e(\"events\").EventEmitter;\n    }, {\n      events: 7\n    }],\n    29: [function (e, t, n) {\n      n = t.exports = e(\"./lib/_stream_readable.js\"), n.Stream = n, n.Readable = n, n.Writable = e(\"./lib/_stream_writable.js\"), n.Duplex = e(\"./lib/_stream_duplex.js\"), n.Transform = e(\"./lib/_stream_transform.js\"), n.PassThrough = e(\"./lib/_stream_passthrough.js\"), n.finished = e(\"./lib/internal/streams/end-of-stream.js\"), n.pipeline = e(\"./lib/internal/streams/pipeline.js\");\n    }, {\n      \"./lib/_stream_duplex.js\": 16,\n      \"./lib/_stream_passthrough.js\": 17,\n      \"./lib/_stream_readable.js\": 18,\n      \"./lib/_stream_transform.js\": 19,\n      \"./lib/_stream_writable.js\": 20,\n      \"./lib/internal/streams/end-of-stream.js\": 24,\n      \"./lib/internal/streams/pipeline.js\": 26\n    }],\n    30: [function (e, t, n) {\n      function r(e, t) {\n        for (var n in e) t[n] = e[n];\n      }\n      function a(e, t, n) {\n        return i(e, t, n);\n      } /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      var o = e(\"buffer\"),\n        i = o.Buffer;\n      i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = o : (r(o, n), n.Buffer = a), a.prototype = Object.create(i.prototype), r(i, a), a.from = function (e, t, n) {\n        if (\"number\" == typeof e) throw new TypeError(\"Argument must not be a number\");\n        return i(e, t, n);\n      }, a.alloc = function (e, t, n) {\n        if (\"number\" != typeof e) throw new TypeError(\"Argument must be a number\");\n        var r = i(e);\n        return void 0 === t ? r.fill(0) : \"string\" == typeof n ? r.fill(t, n) : r.fill(t), r;\n      }, a.allocUnsafe = function (e) {\n        if (\"number\" != typeof e) throw new TypeError(\"Argument must be a number\");\n        return i(e);\n      }, a.allocUnsafeSlow = function (e) {\n        if (\"number\" != typeof e) throw new TypeError(\"Argument must be a number\");\n        return o.SlowBuffer(e);\n      };\n    }, {\n      buffer: 3\n    }],\n    31: [function (e, t, n) {\n      'use strict';\n\n      function r(e) {\n        if (!e) return \"utf8\";\n        for (var t;;) switch (e) {\n          case \"utf8\":\n          case \"utf-8\":\n            return \"utf8\";\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return \"utf16le\";\n          case \"latin1\":\n          case \"binary\":\n            return \"latin1\";\n          case \"base64\":\n          case \"ascii\":\n          case \"hex\":\n            return e;\n          default:\n            if (t) return;\n            e = (\"\" + e).toLowerCase(), t = !0;\n        }\n      }\n      function a(e) {\n        var t = r(e);\n        if (\"string\" != typeof t && (m.isEncoding === b || !b(e))) throw new Error(\"Unknown encoding: \" + e);\n        return t || e;\n      }\n      function o(e) {\n        this.encoding = a(e);\n        var t;\n        switch (this.encoding) {\n          case \"utf16le\":\n            this.text = u, this.end = p, t = 4;\n            break;\n          case \"utf8\":\n            this.fillLast = c, t = 4;\n            break;\n          case \"base64\":\n            this.text = f, this.end = g, t = 3;\n            break;\n          default:\n            return this.write = _, void (this.end = h);\n        }\n        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m.allocUnsafe(t);\n      }\n      function d(e) {\n        if (127 >= e) return 0;\n        return 6 == e >> 5 ? 2 : 14 == e >> 4 ? 3 : 30 == e >> 3 ? 4 : 2 == e >> 6 ? -1 : -2;\n      }\n      function s(e, t, n) {\n        var r = t.length - 1;\n        if (r < n) return 0;\n        var a = d(t[r]);\n        return 0 <= a ? (0 < a && (e.lastNeed = a - 1), a) : --r < n || -2 === a ? 0 : (a = d(t[r]), 0 <= a) ? (0 < a && (e.lastNeed = a - 2), a) : --r < n || -2 === a ? 0 : (a = d(t[r]), 0 <= a ? (0 < a && (2 === a ? a = 0 : e.lastNeed = a - 3), a) : 0);\n      }\n      function l(e, t) {\n        if (128 != (192 & t[0])) return e.lastNeed = 0, \"\\uFFFD\";\n        if (1 < e.lastNeed && 1 < t.length) {\n          if (128 != (192 & t[1])) return e.lastNeed = 1, \"\\uFFFD\";\n          if (2 < e.lastNeed && 2 < t.length && 128 != (192 & t[2])) return e.lastNeed = 2, \"\\uFFFD\";\n        }\n      }\n      function c(e) {\n        var t = this.lastTotal - this.lastNeed,\n          n = l(this, e, t);\n        return void 0 === n ? this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length) : n;\n      }\n      function u(e, t) {\n        if (0 == (e.length - t) % 2) {\n          var n = e.toString(\"utf16le\", t);\n          if (n) {\n            var r = n.charCodeAt(n.length - 1);\n            if (55296 <= r && 56319 >= r) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], n.slice(0, -1);\n          }\n          return n;\n        }\n        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString(\"utf16le\", t, e.length - 1);\n      }\n      function p(e) {\n        var t = e && e.length ? this.write(e) : \"\";\n        if (this.lastNeed) {\n          var n = this.lastTotal - this.lastNeed;\n          return t + this.lastChar.toString(\"utf16le\", 0, n);\n        }\n        return t;\n      }\n      function f(e, t) {\n        var r = (e.length - t) % 3;\n        return 0 == r ? e.toString(\"base64\", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 == r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString(\"base64\", t, e.length - r));\n      }\n      function g(e) {\n        var t = e && e.length ? this.write(e) : \"\";\n        return this.lastNeed ? t + this.lastChar.toString(\"base64\", 0, 3 - this.lastNeed) : t;\n      }\n      function _(e) {\n        return e.toString(this.encoding);\n      }\n      function h(e) {\n        return e && e.length ? this.write(e) : \"\";\n      }\n      var m = e(\"safe-buffer\").Buffer,\n        b = m.isEncoding || function (e) {\n          switch (e = \"\" + e, e && e.toLowerCase()) {\n            case \"hex\":\n            case \"utf8\":\n            case \"utf-8\":\n            case \"ascii\":\n            case \"binary\":\n            case \"base64\":\n            case \"ucs2\":\n            case \"ucs-2\":\n            case \"utf16le\":\n            case \"utf-16le\":\n            case \"raw\":\n              return !0;\n            default:\n              return !1;\n          }\n        };\n      n.StringDecoder = o, o.prototype.write = function (e) {\n        if (0 === e.length) return \"\";\n        var t, n;\n        if (this.lastNeed) {\n          if (t = this.fillLast(e), void 0 === t) return \"\";\n          n = this.lastNeed, this.lastNeed = 0;\n        } else n = 0;\n        return n < e.length ? t ? t + this.text(e, n) : this.text(e, n) : t || \"\";\n      }, o.prototype.end = function (e) {\n        var t = e && e.length ? this.write(e) : \"\";\n        return this.lastNeed ? t + \"\\uFFFD\" : t;\n      }, o.prototype.text = function (e, t) {\n        var n = s(this, e, t);\n        if (!this.lastNeed) return e.toString(\"utf8\", t);\n        this.lastTotal = n;\n        var r = e.length - (n - this.lastNeed);\n        return e.copy(this.lastChar, 0, r), e.toString(\"utf8\", t, r);\n      }, o.prototype.fillLast = function (e) {\n        return this.lastNeed <= e.length ? (e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length);\n      };\n    }, {\n      \"safe-buffer\": 30\n    }],\n    32: [function (e, t) {\n      (function (e) {\n        (function () {\n          function n(t) {\n            try {\n              if (!e.localStorage) return !1;\n            } catch (e) {\n              return !1;\n            }\n            var n = e.localStorage[t];\n            return null != n && \"true\" === (n + \"\").toLowerCase();\n          }\n          t.exports = function (e, t) {\n            function r() {\n              if (!a) {\n                if (n(\"throwDeprecation\")) throw new Error(t);else n(\"traceDeprecation\") ? console.trace(t) : console.warn(t);\n                a = !0;\n              }\n              return e.apply(this, arguments);\n            }\n            if (n(\"noDeprecation\")) return e;\n            var a = !1;\n            return r;\n          };\n        }).call(this);\n      }).call(this, \"undefined\" == typeof global ? \"undefined\" == typeof self ? \"undefined\" == typeof window ? {} : window : self : global);\n    }, {}],\n    \"/\": [function (e, t) {\n      function n(e) {\n        return e.replace(/a=ice-options:trickle\\s\\n/g, \"\");\n      }\n      function r(e) {\n        console.warn(e);\n      } /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n      const a = e(\"debug\")(\"simple-peer\"),\n        o = e(\"get-browser-rtc\"),\n        i = e(\"randombytes\"),\n        d = e(\"readable-stream\"),\n        s = e(\"queue-microtask\"),\n        l = e(\"err-code\"),\n        {\n          Buffer: c\n        } = e(\"buffer\"),\n        u = 65536;\n      class p extends d.Duplex {\n        constructor(e) {\n          if (e = Object.assign({\n            allowHalfOpen: !1\n          }, e), super(e), this._id = i(4).toString(\"hex\").slice(0, 7), this._debug(\"new peer %o\", e), this.channelName = e.initiator ? e.channelName || i(20).toString(\"hex\") : null, this.initiator = e.initiator || !1, this.channelConfig = e.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e.config), this.offerOptions = e.offerOptions || {}, this.answerOptions = e.answerOptions || {}, this.sdpTransform = e.sdpTransform || (e => e), this.streams = e.streams || (e.stream ? [e.stream] : []), this.trickle = void 0 === e.trickle || e.trickle, this.allowHalfTrickle = void 0 !== e.allowHalfTrickle && e.allowHalfTrickle, this.iceCompleteTimeout = e.iceCompleteTimeout || 5000, this.destroyed = !1, this.destroying = !1, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e.wrtc && \"object\" == typeof e.wrtc ? e.wrtc : o(), !this._wrtc) if (\"undefined\" == typeof window) throw l(new Error(\"No WebRTC support: Specify `opts.wrtc` option in this environment\"), \"ERR_WEBRTC_SUPPORT\");else throw l(new Error(\"No WebRTC support: Not a supported browser\"), \"ERR_WEBRTC_SUPPORT\");\n          this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = !1, this._firstNegotiation = !0, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._senderMap = new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;\n          try {\n            this._pc = new this._wrtc.RTCPeerConnection(this.config);\n          } catch (e) {\n            return void this.destroy(l(e, \"ERR_PC_CONSTRUCTOR\"));\n          }\n          this._isReactNativeWebrtc = \"number\" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {\n            this._onIceStateChange();\n          }, this._pc.onicegatheringstatechange = () => {\n            this._onIceStateChange();\n          }, this._pc.onconnectionstatechange = () => {\n            this._onConnectionStateChange();\n          }, this._pc.onsignalingstatechange = () => {\n            this._onSignalingStateChange();\n          }, this._pc.onicecandidate = e => {\n            this._onIceCandidate(e);\n          }, \"object\" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch(e => {\n            this.destroy(l(e, \"ERR_PC_PEER_IDENTITY\"));\n          }), this.initiator || this.channelNegotiated ? this._setupData({\n            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\n          }) : this._pc.ondatachannel = e => {\n            this._setupData(e);\n          }, this.streams && this.streams.forEach(e => {\n            this.addStream(e);\n          }), this._pc.ontrack = e => {\n            this._onTrack(e);\n          }, this._debug(\"initial negotiation\"), this._needsNegotiation(), this._onFinishBound = () => {\n            this._onFinish();\n          }, this.once(\"finish\", this._onFinishBound);\n        }\n        get bufferSize() {\n          return this._channel && this._channel.bufferedAmount || 0;\n        }\n        get connected() {\n          return this._connected && \"open\" === this._channel.readyState;\n        }\n        address() {\n          return {\n            port: this.localPort,\n            family: this.localFamily,\n            address: this.localAddress\n          };\n        }\n        signal(e) {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot signal after peer is destroyed\"), \"ERR_DESTROYED\");\n            if (\"string\" == typeof e) try {\n              e = JSON.parse(e);\n            } catch (t) {\n              e = {};\n            }\n            this._debug(\"signal()\"), e.renegotiate && this.initiator && (this._debug(\"got request to renegotiate\"), this._needsNegotiation()), e.transceiverRequest && this.initiator && (this._debug(\"got request for transceiver\"), this.addTransceiver(e.transceiverRequest.kind, e.transceiverRequest.init)), e.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e.candidate) : this._pendingCandidates.push(e.candidate)), e.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e)).then(() => {\n              this.destroyed || (this._pendingCandidates.forEach(e => {\n                this._addIceCandidate(e);\n              }), this._pendingCandidates = [], \"offer\" === this._pc.remoteDescription.type && this._createAnswer());\n            }).catch(e => {\n              this.destroy(l(e, \"ERR_SET_REMOTE_DESCRIPTION\"));\n            }), e.sdp || e.candidate || e.renegotiate || e.transceiverRequest || this.destroy(l(new Error(\"signal() called with invalid signal data\"), \"ERR_SIGNALING\"));\n          }\n        }\n        _addIceCandidate(e) {\n          const t = new this._wrtc.RTCIceCandidate(e);\n          this._pc.addIceCandidate(t).catch(e => {\n            !t.address || t.address.endsWith(\".local\") ? r(\"Ignoring unsupported ICE candidate.\") : this.destroy(l(e, \"ERR_ADD_ICE_CANDIDATE\"));\n          });\n        }\n        send(e) {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot send after peer is destroyed\"), \"ERR_DESTROYED\");\n            this._channel.send(e);\n          }\n        }\n        addTransceiver(e, t) {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot addTransceiver after peer is destroyed\"), \"ERR_DESTROYED\");\n            if (this._debug(\"addTransceiver()\"), this.initiator) try {\n              this._pc.addTransceiver(e, t), this._needsNegotiation();\n            } catch (e) {\n              this.destroy(l(e, \"ERR_ADD_TRANSCEIVER\"));\n            } else this.emit(\"signal\", {\n              type: \"transceiverRequest\",\n              transceiverRequest: {\n                kind: e,\n                init: t\n              }\n            });\n          }\n        }\n        addStream(e) {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot addStream after peer is destroyed\"), \"ERR_DESTROYED\");\n            this._debug(\"addStream()\"), e.getTracks().forEach(t => {\n              this.addTrack(t, e);\n            });\n          }\n        }\n        addTrack(e, t) {\n          if (this.destroying) return;\n          if (this.destroyed) throw l(new Error(\"cannot addTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n          this._debug(\"addTrack()\");\n          const n = this._senderMap.get(e) || new Map();\n          let r = n.get(t);\n          if (!r) r = this._pc.addTrack(e, t), n.set(t, r), this._senderMap.set(e, n), this._needsNegotiation();else if (r.removed) throw l(new Error(\"Track has been removed. You should enable/disable tracks that you want to re-add.\"), \"ERR_SENDER_REMOVED\");else throw l(new Error(\"Track has already been added to that stream.\"), \"ERR_SENDER_ALREADY_ADDED\");\n        }\n        replaceTrack(e, t, n) {\n          if (this.destroying) return;\n          if (this.destroyed) throw l(new Error(\"cannot replaceTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n          this._debug(\"replaceTrack()\");\n          const r = this._senderMap.get(e),\n            a = r ? r.get(n) : null;\n          if (!a) throw l(new Error(\"Cannot replace track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n          t && this._senderMap.set(t, r), null == a.replaceTrack ? this.destroy(l(new Error(\"replaceTrack is not supported in this browser\"), \"ERR_UNSUPPORTED_REPLACETRACK\")) : a.replaceTrack(t);\n        }\n        removeTrack(e, t) {\n          if (this.destroying) return;\n          if (this.destroyed) throw l(new Error(\"cannot removeTrack after peer is destroyed\"), \"ERR_DESTROYED\");\n          this._debug(\"removeSender()\");\n          const n = this._senderMap.get(e),\n            r = n ? n.get(t) : null;\n          if (!r) throw l(new Error(\"Cannot remove track that was never added.\"), \"ERR_TRACK_NOT_ADDED\");\n          try {\n            r.removed = !0, this._pc.removeTrack(r);\n          } catch (e) {\n            \"NS_ERROR_UNEXPECTED\" === e.name ? this._sendersAwaitingStable.push(r) : this.destroy(l(e, \"ERR_REMOVE_TRACK\"));\n          }\n          this._needsNegotiation();\n        }\n        removeStream(e) {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot removeStream after peer is destroyed\"), \"ERR_DESTROYED\");\n            this._debug(\"removeSenders()\"), e.getTracks().forEach(t => {\n              this.removeTrack(t, e);\n            });\n          }\n        }\n        _needsNegotiation() {\n          this._debug(\"_needsNegotiation\"), this._batchedNegotiation || (this._batchedNegotiation = !0, s(() => {\n            this._batchedNegotiation = !1, this.initiator || !this._firstNegotiation ? (this._debug(\"starting batched negotiation\"), this.negotiate()) : this._debug(\"non-initiator initial negotiation request discarded\"), this._firstNegotiation = !1;\n          }));\n        }\n        negotiate() {\n          if (!this.destroying) {\n            if (this.destroyed) throw l(new Error(\"cannot negotiate after peer is destroyed\"), \"ERR_DESTROYED\");\n            this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug(\"already negotiating, queueing\")) : (this._debug(\"start negotiation\"), setTimeout(() => {\n              this._createOffer();\n            }, 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug(\"already negotiating, queueing\")) : (this._debug(\"requesting negotiation from initiator\"), this.emit(\"signal\", {\n              type: \"renegotiate\",\n              renegotiate: !0\n            })), this._isNegotiating = !0;\n          }\n        }\n        destroy(e) {\n          this._destroy(e, () => {});\n        }\n        _destroy(e, t) {\n          this.destroyed || this.destroying || (this.destroying = !0, this._debug(\"destroying (error: %s)\", e && (e.message || e)), s(() => {\n            if (this.destroyed = !0, this.destroying = !1, this._debug(\"destroy (error: %s)\", e && (e.message || e)), this.readable = this.writable = !1, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener(\"finish\", this._onFinishBound), this._onFinishBound = null, this._channel) {\n              try {\n                this._channel.close();\n              } catch (e) {}\n              this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;\n            }\n            if (this._pc) {\n              try {\n                this._pc.close();\n              } catch (e) {}\n              this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;\n            }\n            this._pc = null, this._channel = null, e && this.emit(\"error\", e), this.emit(\"close\"), t();\n          }));\n        }\n        _setupData(e) {\n          if (!e.channel) return this.destroy(l(new Error(\"Data channel event is missing `channel` property\"), \"ERR_DATA_CHANNEL\"));\n          this._channel = e.channel, this._channel.binaryType = \"arraybuffer\", \"number\" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u), this.channelName = this._channel.label, this._channel.onmessage = e => {\n            this._onChannelMessage(e);\n          }, this._channel.onbufferedamountlow = () => {\n            this._onChannelBufferedAmountLow();\n          }, this._channel.onopen = () => {\n            this._onChannelOpen();\n          }, this._channel.onclose = () => {\n            this._onChannelClose();\n          }, this._channel.onerror = e => {\n            const t = e.error instanceof Error ? e.error : new Error(`Datachannel error: ${e.message} ${e.filename}:${e.lineno}:${e.colno}`);\n            this.destroy(l(t, \"ERR_DATA_CHANNEL\"));\n          };\n          let t = !1;\n          this._closingInterval = setInterval(() => {\n            this._channel && \"closing\" === this._channel.readyState ? (t && this._onChannelClose(), t = !0) : t = !1;\n          }, 5000);\n        }\n        _read() {}\n        _write(e, t, n) {\n          if (this.destroyed) return n(l(new Error(\"cannot write after peer is destroyed\"), \"ERR_DATA_CHANNEL\"));\n          if (this._connected) {\n            try {\n              this.send(e);\n            } catch (e) {\n              return this.destroy(l(e, \"ERR_DATA_CHANNEL\"));\n            }\n            this._channel.bufferedAmount > u ? (this._debug(\"start backpressure: bufferedAmount %d\", this._channel.bufferedAmount), this._cb = n) : n(null);\n          } else this._debug(\"write before connect\"), this._chunk = e, this._cb = n;\n        }\n        _onFinish() {\n          if (!this.destroyed) {\n            const e = () => {\n              setTimeout(() => this.destroy(), 1e3);\n            };\n            this._connected ? e() : this.once(\"connect\", e);\n          }\n        }\n        _startIceCompleteTimeout() {\n          this.destroyed || this._iceCompleteTimer || (this._debug(\"started iceComplete timeout\"), this._iceCompleteTimer = setTimeout(() => {\n            this._iceComplete || (this._iceComplete = !0, this._debug(\"iceComplete timeout completed\"), this.emit(\"iceTimeout\"), this.emit(\"_iceComplete\"));\n          }, this.iceCompleteTimeout));\n        }\n        _createOffer() {\n          this.destroyed || this._pc.createOffer(this.offerOptions).then(e => {\n            if (this.destroyed) return;\n            this.trickle || this.allowHalfTrickle || (e.sdp = n(e.sdp)), e.sdp = this.sdpTransform(e.sdp);\n            const t = () => {\n              if (!this.destroyed) {\n                const t = this._pc.localDescription || e;\n                this._debug(\"signal\"), this.emit(\"signal\", {\n                  type: t.type,\n                  sdp: t.sdp\n                });\n              }\n            };\n            this._pc.setLocalDescription(e).then(() => {\n              this._debug(\"createOffer success\"), this.destroyed || (this.trickle || this._iceComplete ? t() : this.once(\"_iceComplete\", t));\n            }).catch(e => {\n              this.destroy(l(e, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            });\n          }).catch(e => {\n            this.destroy(l(e, \"ERR_CREATE_OFFER\"));\n          });\n        }\n        _requestMissingTransceivers() {\n          this._pc.getTransceivers && this._pc.getTransceivers().forEach(e => {\n            e.mid || !e.sender.track || e.requested || (e.requested = !0, this.addTransceiver(e.sender.track.kind));\n          });\n        }\n        _createAnswer() {\n          this.destroyed || this._pc.createAnswer(this.answerOptions).then(e => {\n            if (this.destroyed) return;\n            this.trickle || this.allowHalfTrickle || (e.sdp = n(e.sdp)), e.sdp = this.sdpTransform(e.sdp);\n            const t = () => {\n              if (!this.destroyed) {\n                const t = this._pc.localDescription || e;\n                this._debug(\"signal\"), this.emit(\"signal\", {\n                  type: t.type,\n                  sdp: t.sdp\n                }), this.initiator || this._requestMissingTransceivers();\n              }\n            };\n            this._pc.setLocalDescription(e).then(() => {\n              this.destroyed || (this.trickle || this._iceComplete ? t() : this.once(\"_iceComplete\", t));\n            }).catch(e => {\n              this.destroy(l(e, \"ERR_SET_LOCAL_DESCRIPTION\"));\n            });\n          }).catch(e => {\n            this.destroy(l(e, \"ERR_CREATE_ANSWER\"));\n          });\n        }\n        _onConnectionStateChange() {\n          this.destroyed || \"failed\" === this._pc.connectionState && this.destroy(l(new Error(\"Connection failed.\"), \"ERR_CONNECTION_FAILURE\"));\n        }\n        _onIceStateChange() {\n          if (this.destroyed) return;\n          const e = this._pc.iceConnectionState,\n            t = this._pc.iceGatheringState;\n          this._debug(\"iceStateChange (connection: %s) (gathering: %s)\", e, t), this.emit(\"iceStateChange\", e, t), (\"connected\" === e || \"completed\" === e) && (this._pcReady = !0, this._maybeReady()), \"failed\" === e && this.destroy(l(new Error(\"Ice connection failed.\"), \"ERR_ICE_CONNECTION_FAILURE\")), \"closed\" === e && this.destroy(l(new Error(\"Ice connection closed.\"), \"ERR_ICE_CONNECTION_CLOSED\"));\n        }\n        getStats(e) {\n          const t = e => (\"[object Array]\" === Object.prototype.toString.call(e.values) && e.values.forEach(t => {\n            Object.assign(e, t);\n          }), e);\n          0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then(n => {\n            const r = [];\n            n.forEach(e => {\n              r.push(t(e));\n            }), e(null, r);\n          }, t => e(t)) : 0 < this._pc.getStats.length ? this._pc.getStats(n => {\n            if (this.destroyed) return;\n            const r = [];\n            n.result().forEach(e => {\n              const n = {};\n              e.names().forEach(t => {\n                n[t] = e.stat(t);\n              }), n.id = e.id, n.type = e.type, n.timestamp = e.timestamp, r.push(t(n));\n            }), e(null, r);\n          }, t => e(t)) : e(null, []);\n        }\n        _maybeReady() {\n          if (this._debug(\"maybeReady pc %s channel %s\", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady) return;\n          this._connecting = !0;\n          const e = () => {\n            this.destroyed || this.getStats((t, n) => {\n              if (this.destroyed) return;\n              t && (n = []);\n              const r = {},\n                a = {},\n                o = {};\n              let i = !1;\n              n.forEach(e => {\n                (\"remotecandidate\" === e.type || \"remote-candidate\" === e.type) && (r[e.id] = e), (\"localcandidate\" === e.type || \"local-candidate\" === e.type) && (a[e.id] = e), (\"candidatepair\" === e.type || \"candidate-pair\" === e.type) && (o[e.id] = e);\n              });\n              const d = e => {\n                i = !0;\n                let t = a[e.localCandidateId];\n                t && (t.ip || t.address) ? (this.localAddress = t.ip || t.address, this.localPort = +t.port) : t && t.ipAddress ? (this.localAddress = t.ipAddress, this.localPort = +t.portNumber) : \"string\" == typeof e.googLocalAddress && (t = e.googLocalAddress.split(\":\"), this.localAddress = t[0], this.localPort = +t[1]), this.localAddress && (this.localFamily = this.localAddress.includes(\":\") ? \"IPv6\" : \"IPv4\");\n                let n = r[e.remoteCandidateId];\n                n && (n.ip || n.address) ? (this.remoteAddress = n.ip || n.address, this.remotePort = +n.port) : n && n.ipAddress ? (this.remoteAddress = n.ipAddress, this.remotePort = +n.portNumber) : \"string\" == typeof e.googRemoteAddress && (n = e.googRemoteAddress.split(\":\"), this.remoteAddress = n[0], this.remotePort = +n[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(\":\") ? \"IPv6\" : \"IPv4\"), this._debug(\"connect local: %s:%s remote: %s:%s\", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);\n              };\n              if (n.forEach(e => {\n                \"transport\" === e.type && e.selectedCandidatePairId && d(o[e.selectedCandidatePairId]), (\"googCandidatePair\" === e.type && \"true\" === e.googActiveConnection || (\"candidatepair\" === e.type || \"candidate-pair\" === e.type) && e.selected) && d(e);\n              }), !i && (!Object.keys(o).length || Object.keys(a).length)) return void setTimeout(e, 100);\n              if (this._connecting = !1, this._connected = !0, this._chunk) {\n                try {\n                  this.send(this._chunk);\n                } catch (e) {\n                  return this.destroy(l(e, \"ERR_DATA_CHANNEL\"));\n                }\n                this._chunk = null, this._debug(\"sent chunk from \\\"write before connect\\\"\");\n                const e = this._cb;\n                this._cb = null, e(null);\n              }\n              \"number\" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug(\"connect\"), this.emit(\"connect\");\n            });\n          };\n          e();\n        }\n        _onInterval() {\n          this._cb && this._channel && !(this._channel.bufferedAmount > u) && this._onChannelBufferedAmountLow();\n        }\n        _onSignalingStateChange() {\n          this.destroyed || (\"stable\" === this._pc.signalingState && (this._isNegotiating = !1, this._debug(\"flushing sender queue\", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach(e => {\n            this._pc.removeTrack(e), this._queuedNegotiation = !0;\n          }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug(\"flushing negotiation queue\"), this._queuedNegotiation = !1, this._needsNegotiation()) : (this._debug(\"negotiated\"), this.emit(\"negotiated\"))), this._debug(\"signalingStateChange %s\", this._pc.signalingState), this.emit(\"signalingStateChange\", this._pc.signalingState));\n        }\n        _onIceCandidate(e) {\n          this.destroyed || (e.candidate && this.trickle ? this.emit(\"signal\", {\n            type: \"candidate\",\n            candidate: {\n              candidate: e.candidate.candidate,\n              sdpMLineIndex: e.candidate.sdpMLineIndex,\n              sdpMid: e.candidate.sdpMid\n            }\n          }) : !e.candidate && !this._iceComplete && (this._iceComplete = !0, this.emit(\"_iceComplete\")), e.candidate && this._startIceCompleteTimeout());\n        }\n        _onChannelMessage(e) {\n          if (this.destroyed) return;\n          let t = e.data;\n          t instanceof ArrayBuffer && (t = c.from(t)), this.push(t);\n        }\n        _onChannelBufferedAmountLow() {\n          if (!this.destroyed && this._cb) {\n            this._debug(\"ending backpressure: bufferedAmount %d\", this._channel.bufferedAmount);\n            const e = this._cb;\n            this._cb = null, e(null);\n          }\n        }\n        _onChannelOpen() {\n          this._connected || this.destroyed || (this._debug(\"on channel open\"), this._channelReady = !0, this._maybeReady());\n        }\n        _onChannelClose() {\n          this.destroyed || (this._debug(\"on channel close\"), this.destroy());\n        }\n        _onTrack(e) {\n          this.destroyed || e.streams.forEach(t => {\n            this._debug(\"on track\"), this.emit(\"track\", e.track, t), this._remoteTracks.push({\n              track: e.track,\n              stream: t\n            }), this._remoteStreams.some(e => e.id === t.id) || (this._remoteStreams.push(t), s(() => {\n              this._debug(\"on stream\"), this.emit(\"stream\", t);\n            }));\n          });\n        }\n        _debug() {\n          const e = [].slice.call(arguments);\n          e[0] = \"[\" + this._id + \"] \" + e[0], a.apply(null, e);\n        }\n      }\n      p.WEBRTC_SUPPORT = !!o(), p.config = {\n        iceServers: [{\n          urls: [\"stun:stun.l.google.com:19302\", \"stun:global.stun.twilio.com:3478\"]\n        }],\n        sdpSemantics: \"unified-plan\"\n      }, p.channelConfig = {}, t.exports = p;\n    }, {\n      buffer: 3,\n      debug: 4,\n      \"err-code\": 6,\n      \"get-browser-rtc\": 8,\n      \"queue-microtask\": 13,\n      randombytes: 14,\n      \"readable-stream\": 29\n    }]\n  }, {}, [])(\"/\");\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}