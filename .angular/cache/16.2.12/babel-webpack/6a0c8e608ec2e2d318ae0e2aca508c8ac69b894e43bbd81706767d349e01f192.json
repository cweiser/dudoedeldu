{"ast":null,"code":"import * as ws from 'lib0/websocket';\nimport * as map from 'lib0/map';\nimport * as error from 'lib0/error';\nimport * as random from 'lib0/random';\nimport * as encoding from 'lib0/encoding';\nimport * as decoding from 'lib0/decoding';\nimport { ObservableV2 } from 'lib0/observable';\nimport * as logging from 'lib0/logging';\nimport * as promise from 'lib0/promise';\nimport * as bc from 'lib0/broadcastchannel';\nimport * as buffer from 'lib0/buffer';\nimport * as math from 'lib0/math';\nimport { createMutex } from 'lib0/mutex';\nimport * as Y from 'yjs'; // eslint-disable-line\nimport Peer from 'simple-peer/simplepeer.min.js';\nimport * as syncProtocol from 'y-protocols/sync';\nimport * as awarenessProtocol from 'y-protocols/awareness';\nimport * as cryptoutils from './crypto.js';\nconst log = logging.createModuleLogger('y-webrtc');\nconst messageSync = 0;\nconst messageQueryAwareness = 3;\nconst messageAwareness = 1;\nconst messageBcPeerId = 4;\n\n/**\n * @type {Map<string, SignalingConn>}\n */\nconst signalingConns = new Map();\n\n/**\n * @type {Map<string,Room>}\n */\nconst rooms = new Map();\n\n/**\n * @param {Room} room\n */\nconst checkIsSynced = room => {\n  let synced = true;\n  room.webrtcConns.forEach(peer => {\n    if (!peer.synced) {\n      synced = false;\n    }\n  });\n  if (!synced && room.synced || synced && !room.synced) {\n    room.synced = synced;\n    room.provider.emit('synced', [{\n      synced\n    }]);\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with all peers');\n  }\n};\n\n/**\n * @param {Room} room\n * @param {Uint8Array} buf\n * @param {function} syncedCallback\n * @return {encoding.Encoder?}\n */\nconst readMessage = (room, buf, syncedCallback) => {\n  const decoder = decoding.createDecoder(buf);\n  const encoder = encoding.createEncoder();\n  const messageType = decoding.readVarUint(decoder);\n  if (room === undefined) {\n    return null;\n  }\n  const awareness = room.awareness;\n  const doc = room.doc;\n  let sendReply = false;\n  switch (messageType) {\n    case messageSync:\n      {\n        encoding.writeVarUint(encoder, messageSync);\n        const syncMessageType = syncProtocol.readSyncMessage(decoder, encoder, doc, room);\n        if (syncMessageType === syncProtocol.messageYjsSyncStep2 && !room.synced) {\n          syncedCallback();\n        }\n        if (syncMessageType === syncProtocol.messageYjsSyncStep1) {\n          sendReply = true;\n        }\n        break;\n      }\n    case messageQueryAwareness:\n      encoding.writeVarUint(encoder, messageAwareness);\n      encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));\n      sendReply = true;\n      break;\n    case messageAwareness:\n      awarenessProtocol.applyAwarenessUpdate(awareness, decoding.readVarUint8Array(decoder), room);\n      break;\n    case messageBcPeerId:\n      {\n        const add = decoding.readUint8(decoder) === 1;\n        const peerName = decoding.readVarString(decoder);\n        if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add || !room.bcConns.has(peerName) && add)) {\n          const removed = [];\n          const added = [];\n          if (add) {\n            room.bcConns.add(peerName);\n            added.push(peerName);\n          } else {\n            room.bcConns.delete(peerName);\n            removed.push(peerName);\n          }\n          room.provider.emit('peers', [{\n            added,\n            removed,\n            webrtcPeers: Array.from(room.webrtcConns.keys()),\n            bcPeers: Array.from(room.bcConns)\n          }]);\n          broadcastBcPeerId(room);\n        }\n        break;\n      }\n    default:\n      console.error('Unable to compute message');\n      return encoder;\n  }\n  if (!sendReply) {\n    // nothing has been written, no answer created\n    return null;\n  }\n  return encoder;\n};\n\n/**\n * @param {WebrtcConn} peerConn\n * @param {Uint8Array} buf\n * @return {encoding.Encoder?}\n */\nconst readPeerMessage = (peerConn, buf) => {\n  const room = peerConn.room;\n  log('received message from ', logging.BOLD, peerConn.remotePeerId, logging.GREY, ' (', room.name, ')', logging.UNBOLD, logging.UNCOLOR);\n  return readMessage(room, buf, () => {\n    peerConn.synced = true;\n    log('synced ', logging.BOLD, room.name, logging.UNBOLD, ' with ', logging.BOLD, peerConn.remotePeerId);\n    checkIsSynced(room);\n  });\n};\n\n/**\n * @param {WebrtcConn} webrtcConn\n * @param {encoding.Encoder} encoder\n */\nconst sendWebrtcConn = (webrtcConn, encoder) => {\n  log('send message to ', logging.BOLD, webrtcConn.remotePeerId, logging.UNBOLD, logging.GREY, ' (', webrtcConn.room.name, ')', logging.UNCOLOR);\n  try {\n    webrtcConn.peer.send(encoding.toUint8Array(encoder));\n  } catch (e) {}\n};\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastWebrtcConn = (room, m) => {\n  log('broadcast message in ', logging.BOLD, room.name, logging.UNBOLD);\n  room.webrtcConns.forEach(conn => {\n    try {\n      conn.peer.send(m);\n    } catch (e) {}\n  });\n};\nexport class WebrtcConn {\n  /**\n   * @param {SignalingConn} signalingConn\n   * @param {boolean} initiator\n   * @param {string} remotePeerId\n   * @param {Room} room\n   */\n  constructor(signalingConn, initiator, remotePeerId, room) {\n    log('establishing connection to ', logging.BOLD, remotePeerId);\n    this.room = room;\n    this.remotePeerId = remotePeerId;\n    this.glareToken = undefined;\n    this.closed = false;\n    this.connected = false;\n    this.synced = false;\n    /**\n     * @type {any}\n     */\n    this.peer = new Peer({\n      initiator,\n      ...room.provider.peerOpts\n    });\n    this.peer.on('signal', signal => {\n      if (this.glareToken === undefined) {\n        // add some randomness to the timestamp of the offer\n        this.glareToken = Date.now() + Math.random();\n      }\n      publishSignalingMessage(signalingConn, room, {\n        to: remotePeerId,\n        from: room.peerId,\n        type: 'signal',\n        token: this.glareToken,\n        signal\n      });\n    });\n    this.peer.on('connect', () => {\n      log('connected to ', logging.BOLD, remotePeerId);\n      this.connected = true;\n      // send sync step 1\n      const provider = room.provider;\n      const doc = provider.doc;\n      const awareness = room.awareness;\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeSyncStep1(encoder, doc);\n      sendWebrtcConn(this, encoder);\n      const awarenessStates = awareness.getStates();\n      if (awarenessStates.size > 0) {\n        const encoder = encoding.createEncoder();\n        encoding.writeVarUint(encoder, messageAwareness);\n        encoding.writeVarUint8Array(encoder, awarenessProtocol.encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));\n        sendWebrtcConn(this, encoder);\n      }\n    });\n    this.peer.on('close', () => {\n      this.connected = false;\n      this.closed = true;\n      if (room.webrtcConns.has(this.remotePeerId)) {\n        room.webrtcConns.delete(this.remotePeerId);\n        room.provider.emit('peers', [{\n          removed: [this.remotePeerId],\n          added: [],\n          webrtcPeers: Array.from(room.webrtcConns.keys()),\n          bcPeers: Array.from(room.bcConns)\n        }]);\n      }\n      checkIsSynced(room);\n      this.peer.destroy();\n      log('closed connection to ', logging.BOLD, remotePeerId);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('error', err => {\n      log('Error in connection to ', logging.BOLD, remotePeerId, ': ', err);\n      announceSignalingInfo(room);\n    });\n    this.peer.on('data', data => {\n      const answer = readPeerMessage(this, data);\n      if (answer !== null) {\n        sendWebrtcConn(this, answer);\n      }\n    });\n  }\n  destroy() {\n    this.peer.destroy();\n  }\n}\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastBcMessage = (room, m) => cryptoutils.encrypt(m, room.key).then(data => room.mux(() => bc.publish(room.name, data)));\n\n/**\n * @param {Room} room\n * @param {Uint8Array} m\n */\nconst broadcastRoomMessage = (room, m) => {\n  if (room.bcconnected) {\n    broadcastBcMessage(room, m);\n  }\n  broadcastWebrtcConn(room, m);\n};\n\n/**\n * @param {Room} room\n */\nconst announceSignalingInfo = room => {\n  signalingConns.forEach(conn => {\n    // only subscribe if connection is established, otherwise the conn automatically subscribes to all rooms\n    if (conn.connected) {\n      conn.send({\n        type: 'subscribe',\n        topics: [room.name]\n      });\n      if (room.webrtcConns.size < room.provider.maxConns) {\n        publishSignalingMessage(conn, room, {\n          type: 'announce',\n          from: room.peerId\n        });\n      }\n    }\n  });\n};\n\n/**\n * @param {Room} room\n */\nconst broadcastBcPeerId = room => {\n  if (room.provider.filterBcConns) {\n    // broadcast peerId via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 1);\n    encoding.writeVarString(encoderPeerIdBc, room.peerId);\n    broadcastBcMessage(room, encoding.toUint8Array(encoderPeerIdBc));\n  }\n};\nexport class Room {\n  /**\n   * @param {Y.Doc} doc\n   * @param {WebrtcProvider} provider\n   * @param {string} name\n   * @param {CryptoKey|null} key\n   */\n  constructor(doc, provider, name, key) {\n    /**\n     * Do not assume that peerId is unique. This is only meant for sending signaling messages.\n     *\n     * @type {string}\n     */\n    this.peerId = random.uuidv4();\n    this.doc = doc;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = provider.awareness;\n    this.provider = provider;\n    this.synced = false;\n    this.name = name;\n    // @todo make key secret by scoping\n    this.key = key;\n    /**\n     * @type {Map<string, WebrtcConn>}\n     */\n    this.webrtcConns = new Map();\n    /**\n     * @type {Set<string>}\n     */\n    this.bcConns = new Set();\n    this.mux = createMutex();\n    this.bcconnected = false;\n    /**\n     * @param {ArrayBuffer} data\n     */\n    this._bcSubscriber = data => cryptoutils.decrypt(new Uint8Array(data), key).then(m => this.mux(() => {\n      const reply = readMessage(this, m, () => {});\n      if (reply) {\n        broadcastBcMessage(this, encoding.toUint8Array(reply));\n      }\n    }));\n    /**\n     * Listens to Yjs updates and sends them to remote peers\n     *\n     * @param {Uint8Array} update\n     * @param {any} _origin\n     */\n    this._docUpdateHandler = (update, _origin) => {\n      const encoder = encoding.createEncoder();\n      encoding.writeVarUint(encoder, messageSync);\n      syncProtocol.writeUpdate(encoder, update);\n      broadcastRoomMessage(this, encoding.toUint8Array(encoder));\n    };\n    /**\n     * Listens to Awareness updates and sends them to remote peers\n     *\n     * @param {any} changed\n     * @param {any} _origin\n     */\n    this._awarenessUpdateHandler = ({\n      added,\n      updated,\n      removed\n    }, _origin) => {\n      const changedClients = added.concat(updated).concat(removed);\n      const encoderAwareness = encoding.createEncoder();\n      encoding.writeVarUint(encoderAwareness, messageAwareness);\n      encoding.writeVarUint8Array(encoderAwareness, awarenessProtocol.encodeAwarenessUpdate(this.awareness, changedClients));\n      broadcastRoomMessage(this, encoding.toUint8Array(encoderAwareness));\n    };\n    this._beforeUnloadHandler = () => {\n      awarenessProtocol.removeAwarenessStates(this.awareness, [doc.clientID], 'window unload');\n      rooms.forEach(room => {\n        room.disconnect();\n      });\n    };\n    if (typeof window !== 'undefined') {\n      window.addEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.on('exit', this._beforeUnloadHandler);\n    }\n  }\n  connect() {\n    this.doc.on('update', this._docUpdateHandler);\n    this.awareness.on('update', this._awarenessUpdateHandler);\n    // signal through all available signaling connections\n    announceSignalingInfo(this);\n    const roomName = this.name;\n    bc.subscribe(roomName, this._bcSubscriber);\n    this.bcconnected = true;\n    // broadcast peerId via broadcastchannel\n    broadcastBcPeerId(this);\n    // write sync step 1\n    const encoderSync = encoding.createEncoder();\n    encoding.writeVarUint(encoderSync, messageSync);\n    syncProtocol.writeSyncStep1(encoderSync, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderSync));\n    // broadcast local state\n    const encoderState = encoding.createEncoder();\n    encoding.writeVarUint(encoderState, messageSync);\n    syncProtocol.writeSyncStep2(encoderState, this.doc);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderState));\n    // write queryAwareness\n    const encoderAwarenessQuery = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessQuery));\n    // broadcast local awareness state\n    const encoderAwarenessState = encoding.createEncoder();\n    encoding.writeVarUint(encoderAwarenessState, messageAwareness);\n    encoding.writeVarUint8Array(encoderAwarenessState, awarenessProtocol.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));\n    broadcastBcMessage(this, encoding.toUint8Array(encoderAwarenessState));\n  }\n  disconnect() {\n    // signal through all available signaling connections\n    signalingConns.forEach(conn => {\n      if (conn.connected) {\n        conn.send({\n          type: 'unsubscribe',\n          topics: [this.name]\n        });\n      }\n    });\n    awarenessProtocol.removeAwarenessStates(this.awareness, [this.doc.clientID], 'disconnect');\n    // broadcast peerId removal via broadcastchannel\n    const encoderPeerIdBc = encoding.createEncoder();\n    encoding.writeVarUint(encoderPeerIdBc, messageBcPeerId);\n    encoding.writeUint8(encoderPeerIdBc, 0); // remove peerId from other bc peers\n    encoding.writeVarString(encoderPeerIdBc, this.peerId);\n    broadcastBcMessage(this, encoding.toUint8Array(encoderPeerIdBc));\n    bc.unsubscribe(this.name, this._bcSubscriber);\n    this.bcconnected = false;\n    this.doc.off('update', this._docUpdateHandler);\n    this.awareness.off('update', this._awarenessUpdateHandler);\n    this.webrtcConns.forEach(conn => conn.destroy());\n  }\n  destroy() {\n    this.disconnect();\n    if (typeof window !== 'undefined') {\n      window.removeEventListener('beforeunload', this._beforeUnloadHandler);\n    } else if (typeof process !== 'undefined') {\n      process.off('exit', this._beforeUnloadHandler);\n    }\n  }\n}\n\n/**\n * @param {Y.Doc} doc\n * @param {WebrtcProvider} provider\n * @param {string} name\n * @param {CryptoKey|null} key\n * @return {Room}\n */\nconst openRoom = (doc, provider, name, key) => {\n  // there must only be one room\n  if (rooms.has(name)) {\n    throw error.create(`A Yjs Doc connected to room \"${name}\" already exists!`);\n  }\n  const room = new Room(doc, provider, name, key);\n  rooms.set(name, /** @type {Room} */room);\n  return room;\n};\n\n/**\n * @param {SignalingConn} conn\n * @param {Room} room\n * @param {any} data\n */\nconst publishSignalingMessage = (conn, room, data) => {\n  if (room.key) {\n    cryptoutils.encryptJson(data, room.key).then(data => {\n      conn.send({\n        type: 'publish',\n        topic: room.name,\n        data: buffer.toBase64(data)\n      });\n    });\n  } else {\n    conn.send({\n      type: 'publish',\n      topic: room.name,\n      data\n    });\n  }\n};\nexport class SignalingConn extends ws.WebsocketClient {\n  constructor(url) {\n    super(url);\n    /**\n     * @type {Set<WebrtcProvider>}\n     */\n    this.providers = new Set();\n    this.on('connect', () => {\n      log(`connected (${url})`);\n      const topics = Array.from(rooms.keys());\n      this.send({\n        type: 'subscribe',\n        topics\n      });\n      rooms.forEach(room => publishSignalingMessage(this, room, {\n        type: 'announce',\n        from: room.peerId\n      }));\n    });\n    this.on('message', m => {\n      switch (m.type) {\n        case 'publish':\n          {\n            const roomName = m.topic;\n            const room = rooms.get(roomName);\n            if (room == null || typeof roomName !== 'string') {\n              return;\n            }\n            const execMessage = data => {\n              const webrtcConns = room.webrtcConns;\n              const peerId = room.peerId;\n              if (data == null || data.from === peerId || data.to !== undefined && data.to !== peerId || room.bcConns.has(data.from)) {\n                // ignore messages that are not addressed to this conn, or from clients that are connected via broadcastchannel\n                return;\n              }\n              const emitPeerChange = webrtcConns.has(data.from) ? () => {} : () => room.provider.emit('peers', [{\n                removed: [],\n                added: [data.from],\n                webrtcPeers: Array.from(room.webrtcConns.keys()),\n                bcPeers: Array.from(room.bcConns)\n              }]);\n              switch (data.type) {\n                case 'announce':\n                  if (webrtcConns.size < room.provider.maxConns) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));\n                    emitPeerChange();\n                  }\n                  break;\n                case 'signal':\n                  if (data.signal.type === 'offer') {\n                    const existingConn = webrtcConns.get(data.from);\n                    if (existingConn) {\n                      const remoteToken = data.token;\n                      const localToken = existingConn.glareToken;\n                      if (localToken && localToken > remoteToken) {\n                        log('offer rejected: ', data.from);\n                        return;\n                      }\n                      // if we don't reject the offer, we will be accepting it and answering it\n                      existingConn.glareToken = undefined;\n                    }\n                  }\n                  if (data.signal.type === 'answer') {\n                    log('offer answered by: ', data.from);\n                    const existingConn = webrtcConns.get(data.from);\n                    existingConn.glareToken = undefined;\n                  }\n                  if (data.to === peerId) {\n                    map.setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);\n                    emitPeerChange();\n                  }\n                  break;\n              }\n            };\n            if (room.key) {\n              if (typeof m.data === 'string') {\n                cryptoutils.decryptJson(buffer.fromBase64(m.data), room.key).then(execMessage);\n              }\n            } else {\n              execMessage(m.data);\n            }\n          }\n      }\n    });\n    this.on('disconnect', () => log(`disconnect (${url})`));\n  }\n}\n\n/**\n * @typedef {Object} ProviderOptions\n * @property {Array<string>} [signaling]\n * @property {string} [password]\n * @property {awarenessProtocol.Awareness} [awareness]\n * @property {number} [maxConns]\n * @property {boolean} [filterBcConns]\n * @property {any} [peerOpts]\n */\n\n/**\n * @param {WebrtcProvider} provider\n */\nconst emitStatus = provider => {\n  provider.emit('status', [{\n    connected: provider.connected\n  }]);\n};\n\n/**\n * @typedef {Object} WebrtcProviderEvents\n * @property {function({connected:boolean}):void} WebrtcProviderEvent.status\n * @property {function({synced:boolean}):void} WebrtcProviderEvent.synced\n * @property {function({added:Array<string>,removed:Array<string>,webrtcPeers:Array<string>,bcPeers:Array<string>}):void} WebrtcProviderEvent.peers\n */\n\n/**\n * @extends ObservableV2<WebrtcProviderEvents>\n */\nexport class WebrtcProvider extends ObservableV2 {\n  /**\n   * @param {string} roomName\n   * @param {Y.Doc} doc\n   * @param {ProviderOptions?} opts\n   */\n  constructor(roomName, doc, {\n    signaling = ['wss://y-webrtc-eu.fly.dev'],\n    password = null,\n    awareness = new awarenessProtocol.Awareness(doc),\n    maxConns = 20 + math.floor(random.rand() * 15),\n    // the random factor reduces the chance that n clients form a cluster\n    filterBcConns = true,\n    peerOpts = {} // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts\n  } = {}) {\n    super();\n    this.roomName = roomName;\n    this.doc = doc;\n    this.filterBcConns = filterBcConns;\n    /**\n     * @type {awarenessProtocol.Awareness}\n     */\n    this.awareness = awareness;\n    this.shouldConnect = false;\n    this.signalingUrls = signaling;\n    this.signalingConns = [];\n    this.maxConns = maxConns;\n    this.peerOpts = peerOpts;\n    /**\n     * @type {PromiseLike<CryptoKey | null>}\n     */\n    this.key = password ? cryptoutils.deriveKey(password, roomName) : /** @type {PromiseLike<null>} */promise.resolve(null);\n    /**\n     * @type {Room|null}\n     */\n    this.room = null;\n    this.key.then(key => {\n      this.room = openRoom(doc, this, roomName, key);\n      if (this.shouldConnect) {\n        this.room.connect();\n      } else {\n        this.room.disconnect();\n      }\n      emitStatus(this);\n    });\n    this.connect();\n    this.destroy = this.destroy.bind(this);\n    doc.on('destroy', this.destroy);\n  }\n\n  /**\n   * Indicates whether the provider is looking for other peers.\n   *\n   * Other peers can be found via signaling servers or via broadcastchannel (cross browser-tab\n   * communication). You never know when you are connected to all peers. You also don't know if\n   * there are other peers. connected doesn't mean that you are connected to any physical peers\n   * working on the same resource as you. It does not change unless you call provider.disconnect()\n   *\n   * `this.on('status', (event) => { console.log(event.connected) })`\n   *\n   * @type {boolean}\n   */\n  get connected() {\n    return this.room !== null && this.shouldConnect;\n  }\n  connect() {\n    this.shouldConnect = true;\n    this.signalingUrls.forEach(url => {\n      const signalingConn = map.setIfUndefined(signalingConns, url, () => new SignalingConn(url));\n      this.signalingConns.push(signalingConn);\n      signalingConn.providers.add(this);\n    });\n    if (this.room) {\n      this.room.connect();\n      emitStatus(this);\n    }\n  }\n  disconnect() {\n    this.shouldConnect = false;\n    this.signalingConns.forEach(conn => {\n      conn.providers.delete(this);\n      if (conn.providers.size === 0) {\n        conn.destroy();\n        signalingConns.delete(conn.url);\n      }\n    });\n    if (this.room) {\n      this.room.disconnect();\n      emitStatus(this);\n    }\n  }\n  destroy() {\n    this.doc.off('destroy', this.destroy);\n    // need to wait for key before deleting room\n    this.key.then(() => {\n      /** @type {Room} */this.room.destroy();\n      rooms.delete(this.roomName);\n    });\n    super.destroy();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}